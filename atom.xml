<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BaoWJ&#39;s Blog</title>
  
  
  <link href="https://1.15.86.100/atom.xml" rel="self"/>
  
  <link href="https://1.15.86.100/"/>
  <updated>2021-09-06T12:34:41.468Z</updated>
  <id>https://1.15.86.100/</id>
  
  <author>
    <name>Bao Wenjie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux-C语言</title>
    <link href="https://1.15.86.100/2021/09/06/Linux-C%E8%AF%AD%E8%A8%80/"/>
    <id>https://1.15.86.100/2021/09/06/Linux-C%E8%AF%AD%E8%A8%80/</id>
    <published>2021-09-06T08:57:21.000Z</published>
    <updated>2021-09-06T12:34:41.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-C语言"><a href="#Linux-C语言" class="headerlink" title="Linux C语言"></a>Linux C语言</h1><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><h3 id="gcc处理过程"><a href="#gcc处理过程" class="headerlink" title="gcc处理过程"></a>gcc处理过程</h3><ul><li><strong>预处理</strong>：<code>gcc -E</code>，将<code>.c</code>文件<strong>头文件展开，宏替换</strong>生成<code>.i</code>文件；</li><li><strong>编译</strong>：<code>gcc -S</code>，将<code>.i</code>文件编译成<strong>汇编文件</strong>生成<code>.s</code>文件；</li><li><strong>汇编</strong>：<code>gcc -c</code>，将<code>.s</code>文件进行<strong>汇编</strong>生成二进制<code>.o</code>文件；</li><li><strong>链接</strong>：<code>gcc</code>，将<code>.o</code>文件和函数库的文件组合生成目标<strong>可执行文件</strong><code>.out</code>；</li></ul><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="o"><a href="#o" class="headerlink" title="-o"></a>-o</h4><p>制定目标名称</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello.exe hello.c</span><br></pre></td></tr></tbody></table></figure><h4 id="g"><a href="#g" class="headerlink" title="-g"></a>-g</h4><p>在编译的时候，产生调试信息。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello.exe hello.c -g</span><br></pre></td></tr></tbody></table></figure><h4 id="I"><a href="#I" class="headerlink" title="-I"></a>-I</h4><p>指定头文件目录</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello.exe hello.c -I /home/c</span><br></pre></td></tr></tbody></table></figure><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>避免源代码泄露</p><h4 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h4><p><code>lib + 库名字 + .a</code></p><h3 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h3><h4 id="编写源代码"><a href="#编写源代码" class="headerlink" title="编写源代码"></a>编写源代码</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//tmp/src/add.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//tmp/src/sub.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//tmp/src/mul.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//tmp/src/div.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> a/b;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//tmp/include/head.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文件结构 */</span></span><br><span class="line">root@VM<span class="number">-0</span><span class="number">-2</span>-ubuntu:~<span class="meta"># tree tmp</span></span><br><span class="line">tmp</span><br><span class="line">├── include</span><br><span class="line">│&nbsp;&nbsp; └── head.h</span><br><span class="line">├── lib</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">    ├── add.c</span><br><span class="line">    ├── div.c</span><br><span class="line">    ├── mul.c</span><br><span class="line">    └── sub.c</span><br></pre></td></tr></tbody></table></figure><h4 id="生成-o-文件"><a href="#生成-o-文件" class="headerlink" title="生成.o 文件"></a>生成<code>.o</code> 文件</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-2-ubuntu:~/tmp/src# gcc -c *.c -I ../include/</span><br><span class="line"></span><br><span class="line">root@VM-0-2-ubuntu:~# tree tmp</span><br><span class="line">tmp</span><br><span class="line">├── include</span><br><span class="line">│&nbsp;&nbsp; └── head.h</span><br><span class="line">├── lib</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">    ├── add.c</span><br><span class="line">    ├── add.o</span><br><span class="line">    ├── div.c</span><br><span class="line">    ├── div.o</span><br><span class="line">    ├── mul.c</span><br><span class="line">    ├── mul.o</span><br><span class="line">    ├── sub.c</span><br><span class="line">    └── sub.o</span><br></pre></td></tr></tbody></table></figure><h4 id="打包-o文件"><a href="#打包-o文件" class="headerlink" title="打包.o文件"></a>打包<code>.o</code>文件</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs [静态库名字] [.o文件]</span><br></pre></td></tr></tbody></table></figure><p><img src="/2021/09/06/Linux-C%E8%AF%AD%E8%A8%80/image-20210906193744531.png" alt="image-20210906193744531"></p><h4 id="发布静态库和头文件"><a href="#发布静态库和头文件" class="headerlink" title="发布静态库和头文件"></a>发布静态库和头文件</h4><p>将<strong>静态库文件<code>.a</code></strong>拷贝到<code>lib</code>目录，头文件存放于<code>include</code>目录即可。</p><p><img src="/2021/09/06/Linux-C%E8%AF%AD%E8%A8%80/image-20210906193949386.png" alt="image-20210906193949386"></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><strong>main.c</strong>文件：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">23</span>, b = <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"add:%d\n"</span>, add(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sub:%d\n"</span>, sub(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mul:%d\n"</span>, mul(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"div:%d\n"</span>, div(a, b));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>编译</strong>：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-2-ubuntu:~/tmp# gcc main.c -o main.out lib/libF.a -I include/</span><br></pre></td></tr></tbody></table></figure><p><strong>运行</strong>：</p><p><img src="/2021/09/06/Linux-C%E8%AF%AD%E8%A8%80/image-20210906194836658.png" alt="image-20210906194836658"></p><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>执行程序体积小；</li><li>动态库更新不需要重新编译程序；</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>加载速度吗；</li><li>比较麻烦；</li></ul><h4 id="命名规则-1"><a href="#命名规则-1" class="headerlink" title="命名规则"></a>命名规则</h4><p><code>lib + 库名字 + .so</code></p><h3 id="生成-o文件"><a href="#生成-o文件" class="headerlink" title="生成.o文件"></a>生成<code>.o</code>文件</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-2-ubuntu:~/tmp/src# gcc -fPIC -c *.c -I ../include/</span><br></pre></td></tr></tbody></table></figure><h3 id="打包-o文件-1"><a href="#打包-o文件-1" class="headerlink" title="打包.o文件"></a>打包<code>.o</code>文件</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-2-ubuntu:~/tmp/src# gcc -shared -o libMyShared.so *.o -I ../include/</span><br></pre></td></tr></tbody></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-2-ubuntu:~/tmp# gcc main.c -o main.out lib/libMyShared.so -I include/</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">Linux下C语言编译。</summary>
    
    
    
    <category term="Linux" scheme="https://1.15.86.100/categories/Linux/"/>
    
    <category term="C" scheme="https://1.15.86.100/categories/Linux/C/"/>
    
    
    <category term="gcc" scheme="https://1.15.86.100/tags/gcc/"/>
    
    <category term="Makefile" scheme="https://1.15.86.100/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>Linux-服务器搭建</title>
    <link href="https://1.15.86.100/2021/09/06/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <id>https://1.15.86.100/2021/09/06/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</id>
    <published>2021-09-06T07:31:55.000Z</published>
    <updated>2021-09-06T12:38:00.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-服务器搭建"><a href="#Linux-服务器搭建" class="headerlink" title="Linux 服务器搭建"></a>Linux 服务器搭建</h1><h2 id="ftp服务器"><a href="#ftp服务器" class="headerlink" title="ftp服务器"></a>ftp服务器</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>文件的上传和下载。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="安装-vsftpd"><a href="#安装-vsftpd" class="headerlink" title="安装 vsftpd"></a>安装 <code>vsftpd</code></h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install vsftpd</span><br></pre></td></tr></tbody></table></figure><p><img src="/2021/09/06/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/image-20210906153652906.png" alt="image-20210906153652906"></p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p><strong>位置</strong>：<code>/etc/vsftpd.conf</code></p><p><img src="/2021/09/06/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/image-20210906153912108.png" alt="image-20210906153912108"></p><p><img src="/2021/09/06/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/image-20210906154127175.png" alt="image-20210906154127175"></p><h4 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service vsftpd restart</span><br></pre></td></tr></tbody></table></figure><h3 id="ftp使用"><a href="#ftp使用" class="headerlink" title="ftp使用"></a>ftp使用</h3><h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put [本地路径] [远程路径]</span><br></pre></td></tr></tbody></table></figure><h4 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get [远程路径] [本地路径]</span><br></pre></td></tr></tbody></table></figure><h2 id="nfs服务器"><a href="#nfs服务器" class="headerlink" title="nfs服务器"></a>nfs服务器</h2><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p><strong>网络文件系统（net file system）</strong>，它可以允许网络中的计算机共享资源。</p><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><h4 id="安装-nfs-kernel-server"><a href="#安装-nfs-kernel-server" class="headerlink" title="安装 nfs-kernel server"></a>安装 <code>nfs-kernel server</code></h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install nfs-kernel-server</span><br></pre></td></tr></tbody></table></figure><h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><p><strong>位置</strong>：<code>/etc/exports</code></p><p><img src="/2021/09/06/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/image-20210906162812642.png" alt="image-20210906162812642"></p><h4 id="重启服务-1"><a href="#重启服务-1" class="headerlink" title="重启服务"></a>重启服务</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nfs-kernel-server restart</span><br></pre></td></tr></tbody></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="本地挂载"><a href="#本地挂载" class="headerlink" title="本地挂载"></a>本地挂载</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [服务器ip:共享目录] [本地位置]</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">ftp文件服务器，ssh服务器，nfs服务器搭建方法。</summary>
    
    
    
    <category term="Linux" scheme="https://1.15.86.100/categories/Linux/"/>
    
    
    <category term="ftp" scheme="https://1.15.86.100/tags/ftp/"/>
    
    <category term="ssh" scheme="https://1.15.86.100/tags/ssh/"/>
    
    <category term="nfs" scheme="https://1.15.86.100/tags/nfs/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="https://1.15.86.100/2021/08/19/KMP%E7%AE%97%E6%B3%95/"/>
    <id>https://1.15.86.100/2021/08/19/KMP%E7%AE%97%E6%B3%95/</id>
    <published>2021-08-19T07:25:18.000Z</published>
    <updated>2021-08-19T13:54:32.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>KMP(Knuth–Morris–Pratt string-searching algorithm)</strong>，由 <a href="https://en.wikipedia.org/wiki/James_H._Morris">James H. Morris</a> 、<a href="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a>、<a href="https://en.wikipedia.org/wiki/Vaughan_Pratt">Vaughan Pratt</a> 共同发明。主要用来查找字符串 <code>S</code> 中是否出现过字符串 <code>W</code>。其时间复杂度为 <script type="math/tex">Θ(m+n)</script>。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>如下所示</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m: 01234567890123456789012</span><br><span class="line">S: ABC ABCDAB ABCDABCDABDE</span><br><span class="line">W:     ABCDABD</span><br><span class="line">i:     0123456</span><br></pre></td></tr></tbody></table></figure><p><strong>ABCDAB</strong>已经匹配成功，且其<strong>最长后缀</strong>，<strong>AB</strong>和<strong>W</strong>（<strong>ABCDABD</strong>）的对应前缀<strong>AB</strong>匹配。</p><p>因此后续步骤中不需要重新匹配<strong>AB</strong>，可以直接从<strong>W[2]</strong>开始匹配，如下图：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m: 01234567890123456789012</span><br><span class="line">S: ABC ABCDAB ABCDABCDABDE</span><br><span class="line">W:         ABCDABD</span><br><span class="line">i:         0123456</span><br></pre></td></tr></tbody></table></figure><p>所以，假设 <strong>S[i]</strong> 和 <strong>W[j]</strong> 不匹配（之前都匹配），<strong>len</strong>表示 <strong>W[0 : j-1]</strong> 的<strong>最长后缀</strong>和 <strong>W</strong> 匹配的长度；</p><p>则下一次其跳转的匹配位置为：<strong>S[i+1]</strong> 和 <strong>W[len + 1]</strong>。</p><h4 id="Next数组计算"><a href="#Next数组计算" class="headerlink" title="Next数组计算"></a>Next数组计算</h4><ul><li><p>Next[0] = 0；</p></li><li><p>对于第 <strong>i + 1</strong> 位置的Next值：</p><ul><li><p>如果 <strong>W[Next[i]] = W[i]</strong>，则 <strong>Next[i + 1] = Next[i] +1</strong>；【待证明1】</p></li><li><p>否则，如果 <strong>W[Next[Next[i]]] = W[Next[i]]</strong>，则 <strong>Next[i + 1] = Next[Next[i]] + 1</strong>；【待证明2】</p></li><li><h6 id="…………"><a href="#…………" class="headerlink" title="…………"></a>…………</h6></li><li><p>否则，<strong>Next[i + 1] = 0</strong>；</p></li></ul></li></ul><h5 id="证明1"><a href="#证明1" class="headerlink" title="证明1"></a>证明1</h5><p>对于数组<strong>W</strong>，设 <strong>Next[i] = k</strong>；</p><p>有：W[0 : k-1] = W[i-k : i-1]；</p><p>又因为 <strong>W[Next[i]] = W[i]</strong>，即 <strong>W[k] = W[i]</strong>，所以有：W[0 : k] = W[i + k : i]；</p><p>所以：<strong>Next[i + 1] = Next[i] +1</strong>；</p><h5 id="证明2"><a href="#证明2" class="headerlink" title="证明2"></a>证明2</h5><p>对于数组<strong>W</strong>，设 <strong>Next[i] = k</strong>，有：W[0 : k-1] = W[i-k : i-1]；</p><p>对于 <strong>Next[Next[i]]</strong> 即 <strong>Next[k]</strong>，令<strong>t = Next[k]</strong>，且 <strong>t &lt; k</strong>有：W[0 : t-1] = W[k-t : k-1]；</p><p>所以：W[0 : t-1] = W[k-t : k-1] = W[i-t : i-1]；</p><p>又因为：<strong>W[Next[Next[i]]] = W[Next[i]]</strong>，即 <strong>W[t] = W[k]</strong>；</p><p>所以：<strong>W[0 : t] = W[i-t : i]</strong>，所以，<strong>Next[i + 1] = t +1</strong>；</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><h4 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h4><blockquote><ul><li>输入：字符串<strong>S</strong>，字符串<strong>W</strong>（被查找）；</li><li>输出：整数<strong>P</strong>（字符串<strong>W</strong>在<strong>S</strong>中的位置）</li><li>令<strong>j=1，k=1</strong>；</li><li>计算<strong>T</strong>数组</li><li><strong>while</strong> j &lt; len(S) <strong>do</strong>：<ul><li><strong>if</strong> W[k] = S[j] <strong>then</strong>：<ul><li>j = j + 1；</li><li>k = k + 1；</li><li><strong>if</strong> k = len(W) <strong>then</strong>：<ul><li>P = j - k；</li><li><strong>return</strong> P；</li></ul></li></ul></li><li><strong>else</strong>：<ul><li>k = T[k]；</li><li>j = j + 1；</li></ul></li></ul></li></ul></blockquote><h4 id="计算T数组子程序"><a href="#计算T数组子程序" class="headerlink" title="计算T数组子程序"></a>计算T数组子程序</h4><blockquote><ul><li>输入：字符串<strong>W</strong>（被查找）；</li><li>输出：数组<strong>Next</strong>；</li><li>令：<ul><li>pos = 1：Next中当前计算的位置；</li><li>cnd = 0;</li></ul></li><li>Next[0] = 0；</li><li><strong>while</strong> pos &lt; len(W) <strong>do</strong>：<ul><li><strong>if</strong> cnd &gt; 1 <strong>and</strong> W[pos - 1] = W[cnd] <strong>then</strong>：<ul><li>Next[pos] = Next[cnd] + 1；</li><li>pos = pos + 1；</li><li>cnd = cnd +1；</li></ul></li><li><strong>else if</strong> cnd = 0：<ul><li>Next[pos] = 0；</li><li>cnd = cnd + 1；</li></ul></li><li><strong>else</strong>：<ul><li>cnd = Next[cnd]；</li></ul></li></ul></li></ul></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> W[MAXN];</span><br><span class="line"><span class="keyword">char</span> S[MAXN];</span><br><span class="line"><span class="keyword">int</span> Next[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">char</span> w[], <span class="keyword">int</span> s_len, <span class="keyword">int</span> w_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="keyword">char</span> w[], <span class="keyword">int</span> w_len, <span class="keyword">int</span> next[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Input S:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S);</span><br><span class="line">    <span class="keyword">int</span> s_len = <span class="built_in">strlen</span>(S);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Input W:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, W);</span><br><span class="line">    <span class="keyword">int</span> w_len = <span class="built_in">strlen</span>(W);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">KMP</span>(S, W, s_len, w_len));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="keyword">char</span> w[], <span class="keyword">int</span> w_len, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; w_len)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">1</span> &amp;&amp; w[i - <span class="number">1</span>] == w[j])</span><br><span class="line">            next[i++] = next[j++] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">            next[i++] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">char</span> w[], <span class="keyword">int</span> s_len, <span class="keyword">int</span> w_len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">get_next</span>(w, w_len, Next);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s_len;)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(s[i] == w[j])</span><br><span class="line">        {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            j = Next[j];</span><br><span class="line">            i++;</span><br><span class="line">        } </span><br><span class="line">        <span class="keyword">if</span>(j == w_len)</span><br><span class="line">            <span class="keyword">return</span> i - w_len + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://github.com/baowj-678/Cpp/tree/master/Algorithm/KMP">Code</a></p>]]></content>
    
    
    <summary type="html">对字符串匹配算法KMP的介绍。</summary>
    
    
    
    <category term="算法" scheme="https://1.15.86.100/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux-系统管理</title>
    <link href="https://1.15.86.100/2021/08/18/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    <id>https://1.15.86.100/2021/08/18/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</id>
    <published>2021-08-18T12:48:21.000Z</published>
    <updated>2021-08-19T13:54:32.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux系统管理"><a href="#Linux系统管理" class="headerlink" title="Linux系统管理"></a>Linux系统管理</h1><h2 id="软件管理"><a href="#软件管理" class="headerlink" title="软件管理"></a>软件管理</h2><h4 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install 软件名</span><br></pre></td></tr></tbody></table></figure><h4 id="软件卸载"><a href="#软件卸载" class="headerlink" title="软件卸载"></a>软件卸载</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt remove 软件名</span><br></pre></td></tr></tbody></table></figure><h4 id="更新安装包"><a href="#更新安装包" class="headerlink" title="更新安装包"></a>更新安装包</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt upgrade</span><br></pre></td></tr></tbody></table></figure><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><p>查看所有进程</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ps [选项]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -aux：查看系统中所有进程，使用BSD操作系统格式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -le：查看系统中所有进程，使用Linux标准命令格式</span></span><br><span class="line"></span><br><span class="line">pstree [选项]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示进程树</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p：显示进程的PID</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -u：显示进程的所属用户</span></span><br></pre></td></tr></tbody></table></figure><p><img src="/2021/08/18/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/image-20210818210901189.png" alt="image-20210818210901189"></p><ul><li><p><strong>USER</strong>：该进程是由哪个用户产生的；</p></li><li><p><strong>PID</strong>：进程的ID号；</p></li><li><p><strong>%CPU</strong>：该进程占用CPU资源的百分比，占用越高，进程越耗费资源；</p></li><li><p><strong>%MEN</strong>：该进程占用物理内存的百分比，占用越高，进程越耗费资源；</p></li><li><p><strong>VSZ</strong>: 该进程占用虚拟内存的大小，单位KB；</p></li><li><p><strong>RSS</strong>：该进程占用实际物理内存的大小，单位KB；</p></li><li><p><strong>TTY</strong>：该进程是在哪个终端中运行的。其中tty1-tty7代表本地控制台终端，tty1-tty6是本地的字符界面终端，tty7 是图形终端。pts/0-255代表虚拟终端；</p></li><li><p><strong>STAT</strong>：进程状态。常见的状态有：</p></li><li><ul><li>R：运行<ul><li>S：睡眠</li><li>T：停止状态</li><li>s：包含子进程</li><li>+：位于后台 </li></ul></li></ul></li><li><p><strong>START</strong>：该进程的启动时间；</p></li><li><p><strong>TIME</strong>：该进程占用CPU的运算时间，注意不是系统时间；</p></li><li><p><strong>COMMAND</strong>：产生此进程的命令名；</p></li></ul><h4 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kill -l</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看可用的进程信号</span></span><br><span class="line"></span><br><span class="line">kill -9 pid</span><br><span class="line"><span class="meta">#</span><span class="bash"> 杀死进程</span></span><br><span class="line"></span><br><span class="line">killall [选项][信号] 进程名 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照进程名杀死进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -i：交互式，询问是否要杀死某个进程</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -I：忽略进程名的大小写</span>  </span><br><span class="line"></span><br><span class="line">pkill [选项] [信号] 进程名 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照进程名终止进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t 终端号：按照终端号踢出用户</span></span><br></pre></td></tr></tbody></table></figure><h4 id="进程后台运行"><a href="#进程后台运行" class="headerlink" title="进程后台运行"></a>进程后台运行</h4><ul><li><p><code>&amp;</code>：在命令后面加上 <code>&amp;</code>；</p>  <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nuhup [命令] $</span><br></pre></td></tr></tbody></table></figure></li><li><p>查看后台进程</p>  <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobs -l</span><br></pre></td></tr></tbody></table></figure></li><li><p>将后台暂停的工作恢复到前台执行；</p>  <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fg %工作号</span><br><span class="line"><span class="meta">#</span><span class="bash"> %工作号：%号可以省略，但是注意工作号和PID的区别</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>把后台暂停的工作恢复到后台执行；</p>  <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bg %工作号</span><br><span class="line"><span class="meta">#</span><span class="bash"> 后台恢复执行的命令，是不能和前台有交互的，否则不能恢复到后台执行。</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 杀死当前bash内运行的进程</span></span><br><span class="line">Ctrl+c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂起当前bash内运行的进程</span></span><br><span class="line">Ctrl+z</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行刚刚挂起的进程</span></span><br><span class="line">Ctrl+y</span><br></pre></td></tr></tbody></table></figure><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><h4 id="查看系统健康状态"><a href="#查看系统健康状态" class="headerlink" title="查看系统健康状态"></a>查看系统健康状态</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">top [ 选项] </span><br><span class="line"><span class="meta">#</span><span class="bash"> -d  秒数：指定top命令每隔几秒更新。默认是3秒 在top命令的交互模式当中可以执行的命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ?或h：显示交互模式的帮助</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> P：以CPU使用率排序，默认就是此项</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> M：以内存的使用率排序</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> N：以PID排序</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> q：退出top</span></span><br></pre></td></tr></tbody></table></figure><h4 id="查看系统资源"><a href="#查看系统资源" class="headerlink" title="查看系统资源"></a>查看系统资源</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat [刷新延时] [刷新次数]  </span><br></pre></td></tr></tbody></table></figure><h4 id="查看开机时内核检测信息"><a href="#查看开机时内核检测信息" class="headerlink" title="查看开机时内核检测信息"></a>查看开机时内核检测信息</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dmesg </span><br><span class="line">dmesg | grep CPU</span><br></pre></td></tr></tbody></table></figure><h4 id="查看内存使用状态"><a href="#查看内存使用状态" class="headerlink" title="查看内存使用状态"></a>查看内存使用状态</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">free [选项]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -b：以字节为单位显示</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -k：以KB为单位显示，默认就是以KB为单位显示</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -m：以MB为单位显示</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -g：以GB为单位显示</span></span><br></pre></td></tr></tbody></table></figure><h4 id="查看CPU信息"><a href="#查看CPU信息" class="headerlink" title="查看CPU信息"></a>查看CPU信息</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></tbody></table></figure><p><img src="/2021/08/18/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/image-20210818214146172.png" alt="image-20210818214146172"></p><h4 id="查看系统与内核相关信息"><a href="#查看系统与内核相关信息" class="headerlink" title="查看系统与内核相关信息"></a>查看系统与内核相关信息</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uname [选项]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -a：查看系统所有相关信息；</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -r：查看内核版本；</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -s：查看内核名称。</span> </span><br></pre></td></tr></tbody></table></figure><p><img src="/2021/08/18/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/image-20210818214302083.png" alt="image-20210818214302083"></p><h4 id="查看当前系统的位数"><a href="#查看当前系统的位数" class="headerlink" title="查看当前系统的位数"></a>查看当前系统的位数</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file /bin/ls</span><br></pre></td></tr></tbody></table></figure><h4 id="查询当前Linux系统的发行版本"><a href="#查询当前Linux系统的发行版本" class="headerlink" title="查询当前Linux系统的发行版本"></a>查询当前Linux系统的发行版本</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></tbody></table></figure><h4 id="查看进程打开或使用的文件信息"><a href="#查看进程打开或使用的文件信息" class="headerlink" title="查看进程打开或使用的文件信息"></a>查看进程打开或使用的文件信息</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsof [选项]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -c  字符串：只列出以字符串开头的进程打开的文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -u  用户名：只列出某个用户的进程打开的文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p  pid：列出某个PID进程打开的文件</span></span><br></pre></td></tr></tbody></table></figure><h2 id="启动管理"><a href="#启动管理" class="headerlink" title="启动管理"></a>启动管理</h2><h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3><h4 id="查看运行级别"><a href="#查看运行级别" class="headerlink" title="查看运行级别"></a>查看运行级别</h4><p><code>runlevel</code></p><h4 id="改变运行级别"><a href="#改变运行级别" class="headerlink" title="改变运行级别"></a>改变运行级别</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init 运行级别</span><br></pre></td></tr></tbody></table></figure><h4 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h4><p>​                 <img src="/2021/08/18/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/1.png" alt="img"></p><h2 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h2><h4 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dump [选项] 备份之后的文件名 原文件或目录</span><br><span class="line"><span class="meta">#</span><span class="bash"> -level：0-9十个备份级别</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -f 文件名：指定备份之后的文件名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -u：备份成功之后，把备份时间记录在/etc/dumpdates文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v：显示备份过程中更多的输出信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -j：调用bzlib库压缩备份文件，其实就是把备份文件压缩为.bz2格式，默认压缩等级是2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -W：显示允许被dump的分区的备份等级及备份时间</span></span><br></pre></td></tr></tbody></table></figure><h4 id="restore"><a href="#restore" class="headerlink" title="restore"></a>restore</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">restore [模式选项] [选项]  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 模式选项：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -C：比较备份数据和实际数据的变化</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -i：进入交互模式，手工选择需要恢复的文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t：查看模式，用于查看备份文件中拥有哪些数据</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -r：还原模式，用于数据还原</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选项：</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> -f：指定备份文件的文件名</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">Linux系统管理。</summary>
    
    
    
    <category term="Linux" scheme="https://1.15.86.100/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo-多设备配置</title>
    <link href="https://1.15.86.100/2021/08/18/Hexo-%E5%A4%9A%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    <id>https://1.15.86.100/2021/08/18/Hexo-%E5%A4%9A%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/</id>
    <published>2021-08-18T03:44:57.000Z</published>
    <updated>2021-08-18T12:29:28.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-多设备配置"><a href="#Hexo-多设备配置" class="headerlink" title="Hexo-多设备配置"></a>Hexo-多设备配置</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h2 id="git服务器配置"><a href="#git服务器配置" class="headerlink" title="git服务器配置"></a>git服务器配置</h2><h2 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h2><h2 id="其他设备配置-ubuntu"><a href="#其他设备配置-ubuntu" class="headerlink" title="其他设备配置(ubuntu)"></a>其他设备配置(ubuntu)</h2><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo install npm</span><br><span class="line"></span><br><span class="line">npm install hexo</span><br></pre></td></tr></tbody></table></figure><h3 id="克隆文件仓库"><a href="#克隆文件仓库" class="headerlink" title="克隆文件仓库"></a>克隆文件仓库</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone ubuntu@1.15.86.100:/hexo/GitLibrary/data.git</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">利用git仓库保存hexo文件，可以在多个设备编辑博客并实现同步。</summary>
    
    
    
    <category term="blog" scheme="https://1.15.86.100/categories/blog/"/>
    
    
    <category term="Hexo" scheme="https://1.15.86.100/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Linux-Shell编程</title>
    <link href="https://1.15.86.100/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/"/>
    <id>https://1.15.86.100/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/</id>
    <published>2021-08-16T15:07:12.000Z</published>
    <updated>2021-08-18T12:29:28.145Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell简介"><a href="#Shell简介" class="headerlink" title="Shell简介"></a>Shell简介</h1><h2 id="Shell简介-1"><a href="#Shell简介-1" class="headerlink" title="Shell简介"></a>Shell简介</h2><h3 id="Shell是什么"><a href="#Shell是什么" class="headerlink" title="Shell是什么"></a>Shell是什么</h3><ul><li>Shell是一个<strong>命令行解释器</strong>，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序；</li><li>Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。Shell是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令；</li></ul><h3 id="Shell分类"><a href="#Shell分类" class="headerlink" title="Shell分类"></a>Shell分类</h3><ul><li><p><strong>Bourne Shell</strong>：从1979起Unix就开始使用Bourne Shell，Bourne Shell的主文件名为<strong>sh</strong>，Bourne家族主要包括sh、ksh、<strong>Bash</strong>、psh、zsh；</p></li><li><p><strong>C Shell</strong>： C Shell主要在BSD版的Unix系统中使用，其语法和C语言相类似而得名，C家族主要包括：csh、tcsh；</p></li><li><strong>Bash</strong>： Bash与sh兼容，现在使用的Linux 就是使用Bash作为用户的基本Shell；</li></ul><h3 id="查看Linux支持的shell"><a href="#查看Linux支持的shell" class="headerlink" title="查看Linux支持的shell"></a>查看Linux支持的shell</h3><p><code>/etc/shells</code></p><p><img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/image-20210816231159818.png" alt="image-20210816231159818"></p><h2 id="Bash基本功能"><a href="#Bash基本功能" class="headerlink" title="Bash基本功能"></a>Bash基本功能</h2><h3 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h3><ul><li>直接运行：<code>./hello.sh</code>；</li><li>Bash调用执行脚本：<code>bash hello.sh</code>，<code>sh hello.sh</code>；</li></ul><h3 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo [选项] [输出内容]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -e： 支持反斜线控制的字符转换</span></span><br></pre></td></tr></tbody></table></figure><h3 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h3><p><code>history</code></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">history [选项] [历史命令保存文件]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -c：清空历史命令</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -w：把缓存中的历史命令写入历史命令保存文件，保存在：~/.bash_history</span> </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h3><h4 id="设置别名-1"><a href="#设置别名-1" class="headerlink" title="设置别名"></a>设置别名</h4><p><code>alias 别名='原命令'</code></p><h4 id="删除别名"><a href="#删除别名" class="headerlink" title="删除别名"></a>删除别名</h4><p><code>unalias 别名</code></p><h4 id="查看别名"><a href="#查看别名" class="headerlink" title="查看别名"></a>查看别名</h4><p><code>alias</code></p><h3 id="命令执行顺序"><a href="#命令执行顺序" class="headerlink" title="命令执行顺序"></a>命令执行顺序</h3><p>1 第一顺位执行用绝对路径或相对路径执行的命令；</p><p>2 第二顺位执行别名；</p><p>3 第三顺位执行Bash的内部命令； </p><p>4 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令；</p><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>​                 <img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/1.png" alt="img">        </p><p>​                 <img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/2.png" alt="img">        </p><h3 id="多命令与管道"><a href="#多命令与管道" class="headerlink" title="多命令与管道"></a>多命令与管道</h3><p>​                 <img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/3.png" alt="img">        </p><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p><code>命令1  |  命令2</code></p><p>命令1的正确输出作为命令2的操作对象</p><h3 id="通配符与特殊符号"><a href="#通配符与特殊符号" class="headerlink" title="通配符与特殊符号"></a>通配符与特殊符号</h3><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>​                 <img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/4.png" alt="img">        </p><h4 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h4><p>​                 <img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/5.png" alt="img">        </p><h3 id="Bash的变量"><a href="#Bash的变量" class="headerlink" title="Bash的变量"></a>Bash的变量</h3><h4 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name="bwj"</span><br></pre></td></tr></tbody></table></figure><h4 id="变量调用"><a href="#变量调用" class="headerlink" title="变量调用"></a>变量调用</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $name</span><br></pre></td></tr></tbody></table></figure><h4 id="变量查看"><a href="#变量查看" class="headerlink" title="变量查看"></a>变量查看</h4><p>查看Bash所有变量</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set</span><br></pre></td></tr></tbody></table></figure><h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset [变量名]</span><br></pre></td></tr></tbody></table></figure><h3 id="Bash运算符"><a href="#Bash运算符" class="headerlink" title="Bash运算符"></a>Bash运算符</h3><h4 id="声明变量类型"><a href="#声明变量类型" class="headerlink" title="声明变量类型"></a>声明变量类型</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">declare [+/-][选项] 变量名</span><br><span class="line"><span class="meta">#</span><span class="bash"> -：给变量设定类型属性</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> +：取消变量的类型属性</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -i：将变量声明为整数型（<span class="built_in">integer</span>）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -x：将变量声明为环境变量</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p：显示指定变量的被声明的类型</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">declare</span> -i cc=<span class="variable">$aa</span>+<span class="variable">$bb</span></span></span><br></pre></td></tr></tbody></table></figure><h4 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h4><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p><code>declare -i cc=$aa+$bb</code></p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p><strong>expr或let数值运算工具</strong></p><p> <code>dd=$(expr $​aa + $bb)</code></p><ul><li>dd的值是aa和bb的和。注意“+”号左右两侧必须有空格；</li></ul><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p><strong>“$((运算式))”或“$[运算式]”</strong></p><p><code>ff=$(( $aa+$bb ))</code></p><p><code>gg=$[ $aa+$bb ]</code></p><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>​                 <img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/9.png" alt="img"></p><pre><code>  #### 变量测试与内容替换 </code></pre><p><img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/10.png" alt="img"></p><p>​        </p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p><code>export 变量名=变量值</code> </p><h4 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h4><p><code>env</code> </p><h4 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h4><p><code>unset 变量名</code></p><h4 id="添加PATH"><a href="#添加PATH" class="headerlink" title="添加PATH"></a>添加PATH</h4><p><code>PATH="$PATH":/root/sh</code>【重启会消失】</p><h4 id="系统提示符"><a href="#系统提示符" class="headerlink" title="系统提示符"></a>系统提示符</h4><p>定义系统提示符（例如：<code>ubuntu@VM-0-2-ubuntu:~$</code>）的变量：<code>PS1</code> </p><ul><li><p><strong>\d</strong>：显示日期，格式为“星期 月 日”；</p></li><li><p><strong>\h</strong>：显示简写主机名。如默认主机名“localhost” ；</p></li><li><p><strong>\t</strong>：显示24小时制时间，格式为“HH:MM:SS” ；</p></li><li><p><strong>\T</strong>：显示12小时制时间，格式为“HH:MM:SS”；</p></li><li><p><strong>\A</strong>：显示24小时制时间，格式为“HH:MM” ；</p></li><li><p><strong>\u</strong>：显示当前用户名；</p></li><li><p><strong>\w</strong>：显示当前所在目录的完整名称；</p></li><li><p><strong>\W</strong>：显示当前所在目录的最后一个目录；</p></li><li><p><strong>#</strong>：执行的第几个命令；</p></li><li><p><strong>$</strong>：提示符。如果是root用户会显示提示符为“#”，如果是普通用户会显示提示符为“$”；</p></li></ul><h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><h4 id="配置文件简介"><a href="#配置文件简介" class="headerlink" title="配置文件简介"></a>配置文件简介</h4><p>环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量，比如<strong>PATH、HISTSIZE、PS1、HOSTNAME</strong>等默认环境变量。</p><ul><li>/etc/profile </li><li>/etc/profile.d/*.sh </li><li>~/.bash_profile </li><li>~/.bashrc </li><li>/etc/bashrc</li></ul><h4 id="环境变量配置文件调用顺序"><a href="#环境变量配置文件调用顺序" class="headerlink" title="环境变量配置文件调用顺序"></a>环境变量配置文件调用顺序</h4><p>​                 <img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/11.png" alt="img"> </p><h4 id="etc-profile的作用"><a href="#etc-profile的作用" class="headerlink" title="/etc/profile的作用"></a>/etc/profile的作用</h4><ul><li><strong>USER</strong>变量；</li><li><strong>LOGNAME</strong>变量；</li><li><strong>MAIL</strong>变量；</li><li><strong>PATH</strong>变量；</li><li><strong>HOSTNAME</strong>变量；</li><li><strong>HISTSIZE</strong>变量；</li><li><strong>umask</strong>；</li><li>调用<strong>/etc/profile.d/*.sh</strong>文件；</li></ul><h4 id="bash-history"><a href="#bash-history" class="headerlink" title="~/bash_history"></a>~/bash_history</h4><p>历史命令</p><h4 id="重新加载配置文件"><a href="#重新加载配置文件" class="headerlink" title="重新加载配置文件"></a>重新加载配置文件</h4><p><code>source 配置文件</code></p><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><p>​                 <img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/6.png" alt="img"> </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 加法程序</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">num1=$1</span><br><span class="line">num2=$2</span><br><span class="line">sum=$(($num1 + $num2))</span><br><span class="line">echo $sum</span><br></pre></td></tr></tbody></table></figure><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><h4 id="预定义变量-1"><a href="#预定义变量-1" class="headerlink" title="预定义变量"></a>预定义变量</h4><p>​                 <img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/8.png" alt="img"></p><h4 id="接收键盘输入"><a href="#接收键盘输入" class="headerlink" title="接收键盘输入"></a>接收键盘输入</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read [选项] [变量名]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -p “提示信息”：在等待<span class="built_in">read</span>输入时，输出提示信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t 秒数：<span class="built_in">read</span>命令会一直等待用户输入，使用此选项可以指定等待时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -n 字符数：<span class="built_in">read</span>命令只接受指定的字符数，就会执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -s：隐藏输入的数据，适用于机密信息的输入</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h2><h3 id="比较判断"><a href="#比较判断" class="headerlink" title="比较判断"></a>比较判断</h3><h4 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test [] /root/install.log</span><br><span class="line"></span><br><span class="line">[ [选项] /root/install.log ]</span><br></pre></td></tr></tbody></table></figure><h4 id="按照文件类型"><a href="#按照文件类型" class="headerlink" title="按照文件类型"></a>按照文件类型</h4><p><img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/13.png" alt=""></p><h4 id="按照文件权限判断"><a href="#按照文件权限判断" class="headerlink" title="按照文件权限判断"></a>按照文件权限判断</h4><p><img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/14.png" alt=""></p><h4 id="两个文件之间进行比较"><a href="#两个文件之间进行比较" class="headerlink" title="两个文件之间进行比较"></a>两个文件之间进行比较</h4><p><img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/15.png" alt=""></p><h4 id="整数比较"><a href="#整数比较" class="headerlink" title="整数比较"></a>整数比较</h4><p><img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/16.png" alt=""></p><h4 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断"></a>字符串判断</h4><p><img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/17.png" alt=""></p><h4 id="多重条件判断"><a href="#多重条件判断" class="headerlink" title="多重条件判断"></a>多重条件判断</h4><p><img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/18.png" alt=""></p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ];then</span><br><span class="line">程序</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################</span></span></span><br><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">程序</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################</span></span></span><br><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">程序</span><br><span class="line">elif [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">程序</span><br><span class="line">else</span><br><span class="line">程序</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure><h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">case "$变量名" in  </span><br><span class="line">    "值1")</span><br><span class="line">         如果变量的值等于值1，则执行程序1</span><br><span class="line">; ;</span><br><span class="line">    "值2")   </span><br><span class="line">         如果变量的值等于值2，则执行程序2  </span><br><span class="line">; ;  </span><br><span class="line">      …省略其他分支…  </span><br><span class="line">*)</span><br><span class="line">      如果变量的值都不是以上的值，则执行此程序 </span><br><span class="line">; ;</span><br><span class="line">esac</span><br></pre></td></tr></tbody></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3</span><br><span class="line">    do </span><br><span class="line">        程序</span><br><span class="line">    done</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################</span></span></span><br><span class="line">for((初始值;循环控制条件;变量变化))</span><br><span class="line">    do</span><br><span class="line">        程序</span><br><span class="line">    done</span><br></pre></td></tr></tbody></table></figure><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">    do</span><br><span class="line">        程序</span><br><span class="line">    done</span><br></pre></td></tr></tbody></table></figure><h4 id="until"><a href="#until" class="headerlink" title="until"></a>until</h4><p>until循环，和while循环相反，until循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until [ 条件判断式 ]</span><br><span class="line">    do</span><br><span class="line">        程序</span><br><span class="line">    done</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">Shell编程的语法。</summary>
    
    
    
    <category term="Linux" scheme="https://1.15.86.100/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux-文件系统管理</title>
    <link href="https://1.15.86.100/2021/08/16/Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    <id>https://1.15.86.100/2021/08/16/Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</id>
    <published>2021-08-16T02:31:13.000Z</published>
    <updated>2021-08-16T03:12:49.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-文件系统管理"><a href="#Linux-文件系统管理" class="headerlink" title="Linux 文件系统管理"></a>Linux 文件系统管理</h1><h2 id="分区和文件系统"><a href="#分区和文件系统" class="headerlink" title="分区和文件系统"></a>分区和文件系统</h2><h3 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h3><ul><li><strong>主分区</strong>：总共最多只能分<strong>四</strong>个；</li><li><p><strong>扩展分区</strong>：只能有一个，也算作主分区的一种，也就是说<strong>主分区加扩展分区最多有四个</strong>。但是扩展分区不能存储数据和格式化，必须再划分成逻辑分区才能使用；</p></li><li><p><strong>逻辑分区</strong>：逻辑分区是在扩展分区中划分的，如果是IDE硬盘，Linux最多支持59个逻辑分区，如果是SCSI硬盘Linux最多支持11个逻辑分区；</p></li></ul><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ul><li><strong>ext2</strong>：是ext文件系统的升级版本，Red Hat Linux7.2版本以前的系统默认都是ext2 文件系统。1993年发布，<strong>最大支持16TB 的分区和最大2TB的文件</strong>（1TB=1024GB=1024*1024KB）；</li><li><strong>ext3</strong>： ext3文件系统是ext2文件系统的升级版本，最大的区别就是<strong>带日志功能</strong>，以在系统突然停止时提高文件系统的可靠性。支持最大16TB的分区和最大2TB的文件；</li><li><strong>ext4</strong>：它是ext3文件系统的升级版。ext4 在性能、伸缩性和可靠性方面进行了大量改进。EXT4 的变化可以说是翻天覆地的，比如向下兼容EXT3、<strong>最大1EB文件系统和16TB文件</strong>、无限数量子目录、Extents连续数据块概念、多块分配、延迟分配、持久预分配、快速FSCK、日志校验、无日志模式、在线碎片整理、inode增强、默认启用barrier等。是CentOS 6.3的默认文件系统      （1EB=1024PB=1024*1024TB）；</li></ul><h2 id="文件系统常用命令"><a href="#文件系统常用命令" class="headerlink" title="文件系统常用命令"></a>文件系统常用命令</h2><h3 id="普通命令"><a href="#普通命令" class="headerlink" title="普通命令"></a>普通命令</h3><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>查看文件系统</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df  [选项] [挂载点]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -a：显示所有的文件系统信息，包括特殊文件系统，如 /proc、/sysfs</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -h：使用习惯单位显示容量，如KB，MB或GB等</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -T：显示文件系统类型</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -m：以MB为单位显示容量</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -k：以KB为单位显示容量。默认就是以KB为单位</span></span><br></pre></td></tr></tbody></table></figure><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><p>统计目录或文件大小</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">du [选项] [目录或文件名]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -a：显示每个子文件的磁盘占用量。默认只统计 子目录的磁盘占用量</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -h：使用习惯单位显示磁盘占用量，如KB，MB  或GB等</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -s：统计总占用量，而不列出子目录和子文件的 占用量</span></span><br></pre></td></tr></tbody></table></figure><h4 id="fsck"><a href="#fsck" class="headerlink" title="fsck"></a>fsck</h4><p>文件系统修复命令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fsck [选项] 分区设备文件名</span><br><span class="line"><span class="meta">#</span><span class="bash"> -a：不用显示用户提示，自动修复文件系统；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -y：自动修复。和-a作用一致，不过有些文件系统只支持-y</span></span><br></pre></td></tr></tbody></table></figure><h4 id="dumpe2fs"><a href="#dumpe2fs" class="headerlink" title="dumpe2fs"></a>dumpe2fs</h4><p>显示磁盘状态</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpe2fs 分区设备文件名</span><br></pre></td></tr></tbody></table></figure><h3 id="挂载命令"><a href="#挂载命令" class="headerlink" title="挂载命令"></a>挂载命令</h3><h4 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount [选项]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -l：查询系统中已经挂载的设备，会显示卷标名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> –a：依据配置文件/etc/fstab的内容，自动挂载</span></span><br></pre></td></tr></tbody></table></figure><p>~~~shell<br>mount [-t 文件系统] [-L 卷标名]  [-o 特殊选项]  设备文件名 挂载点</p><h1 id="t-文件系统：加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660等文件系统"><a href="#t-文件系统：加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660等文件系统" class="headerlink" title="-t 文件系统：加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660等文件系统"></a>-t 文件系统：加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660等文件系统</h1><h1 id="L-卷标名：-挂载指定卷标的分区，而不是安装设备文件名挂载"><a href="#L-卷标名：-挂载指定卷标的分区，而不是安装设备文件名挂载" class="headerlink" title="-L 卷标名： 挂载指定卷标的分区，而不是安装设备文件名挂载"></a>-L 卷标名： 挂载指定卷标的分区，而不是安装设备文件名挂载</h1><h1 id="o-特殊选项：可以指定挂载的额外选项"><a href="#o-特殊选项：可以指定挂载的额外选项" class="headerlink" title="-o 特殊选项：可以指定挂载的额外选项"></a>-o 特殊选项：可以指定挂载的额外选项</h1>]]></content>
    
    
    <summary type="html">对Linux分区文件系统的介绍，文件系统常用命令，fdisk分区，/etc/fstab文件修复，分配swap分区。</summary>
    
    
    
    <category term="Linux" scheme="https://1.15.86.100/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux-用户管理</title>
    <link href="https://1.15.86.100/2021/08/14/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <id>https://1.15.86.100/2021/08/14/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</id>
    <published>2021-08-14T08:44:51.000Z</published>
    <updated>2021-08-15T03:00:07.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h2 id="用户管理文件"><a href="#用户管理文件" class="headerlink" title="用户管理文件"></a>用户管理文件</h2><h3 id="etc-passwd【用户信息文件】"><a href="#etc-passwd【用户信息文件】" class="headerlink" title="/etc/passwd【用户信息文件】"></a>/etc/passwd【用户信息文件】</h3><p>可以使用<code>man 5 passwd</code>查看配置信息。</p><h4 id="配置信息详情"><a href="#配置信息详情" class="headerlink" title="配置信息详情"></a>配置信息详情</h4><p><img src="/2021/08/14/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20210814165205912.png" alt="image-20210814165205912"></p><p>每个字段用 <strong>:</strong> 分割。</p><ul><li><p>第1字段：用户名称；</p></li><li><p>第2字段：密码标志 ；</p></li><li><p>第3字段：UID（用户ID） ；</p></li><li><ul><li>0：   超级用户 ；<ul><li>1-499：  系统用户（伪用户）；</li><li>500-65535： 普通用户(centos7 从1000开始计算)；</li></ul></li></ul></li><li><p>第4字段：GID（用户初始组ID）[不推荐修改初始组]；</p></li><li><p>第5字段：用户说明 ；</p></li><li><p>第6字段：家目录 ；</p></li><li><ul><li>普通用户：/home/用户名/； <ul><li>超级用户：/root/ ；</li></ul></li></ul></li><li><p>第7字段：登录之后的Shell；</p></li></ul><h3 id="etc-shadow【影子文件】"><a href="#etc-shadow【影子文件】" class="headerlink" title="/etc/shadow【影子文件】"></a>/etc/shadow【影子文件】</h3><p>可以使用<code>man 5 shadow</code>查看配置信息。</p><h4 id="详细配置信息"><a href="#详细配置信息" class="headerlink" title="详细配置信息"></a>详细配置信息</h4><p><img src="/2021/08/14/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20210814170742873.png" alt="image-20210814170742873"></p><ul><li><p>第1字段：用户名；</p></li><li><p>第2字段：加密密码 ；</p></li><li><ul><li>加密算法升级为SHA512散列加密算法；<ul><li>如果密码位是<strong>“!!”</strong>或<strong>“*”</strong>代表没有密码，不能登录；</li></ul></li></ul></li><li><p>第3字段：密码最后一次修改日期；</p></li><li><ul><li>使用1970年1月1日作为标准时间，每过一天时间戳加1；</li></ul></li><li><p>第4字段：两次密码的修改间隔时间（和第3字段相比）；</p></li><li>第5字段：密码有效期（和第3字段相比）；</li><li><p>第6字段：密码修改到期前的警告天数（和第5字段相比）；</p></li><li><p>第7字段：密码过期后的宽限天数（和第5 字段相比）；</p></li><li><ul><li>0：代表密码过期后立即失效；<ul><li>-1：则代表密码永远不会失效； </li></ul></li></ul></li><li><p>第8字段：账号失效时间；</p></li><li><ul><li>要用时间戳表示 </li></ul></li><li><p>第9字段：保留</p></li></ul><h3 id="etc-group【组信息文件】"><a href="#etc-group【组信息文件】" class="headerlink" title="/etc/group【组信息文件】"></a>/etc/group【组信息文件】</h3><p>可以使用<code>man 5 group</code>查看配置信息。</p><h4 id="详细信息"><a href="#详细信息" class="headerlink" title="详细信息"></a>详细信息</h4><p><img src="/2021/08/14/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20210814171614809.png" alt="image-20210814171614809"></p><ul><li>第一字段：组名；</li><li>第二字段：组密码标志；</li><li>第三字段：GID；</li><li>第四字段：组中附加用户；</li></ul><h3 id="etc-gshadow【组密码文件】"><a href="#etc-gshadow【组密码文件】" class="headerlink" title="/etc/gshadow【组密码文件】"></a>/etc/gshadow【组密码文件】</h3><ul><li>第一字段：组名；</li><li>第二字段：组密码 (不推荐使用，可以理解为给组设置个小组长)；</li><li>第三字段：组管理员用户名；</li><li>第四字段：组中附加用户；</li></ul><h3 id="用户相关目录"><a href="#用户相关目录" class="headerlink" title="用户相关目录"></a>用户相关目录</h3><h4 id="家目录"><a href="#家目录" class="headerlink" title="家目录"></a>家目录</h4><ul><li>普通用户：<code>/home/用户名/</code>，所有者和所属组都是此用户，权限是700 </li><li>超级用户：<code>/root/</code>，所有者和所属组都是root用户，权限是550 </li></ul><h4 id="用户邮箱"><a href="#用户邮箱" class="headerlink" title="用户邮箱"></a>用户邮箱</h4><ul><li><code>/var/spool/mail/用户名/</code> </li></ul><h4 id="用户模板目录"><a href="#用户模板目录" class="headerlink" title="用户模板目录"></a>用户模板目录</h4><ul><li><code>/etc/skel/</code></li></ul><h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><p>添加用户</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useradd [选项] [用户名]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -u UID： 手工指定用户的UID号</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 家目录： 手工指定用户的家目录</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -c 用户说明： 手工指定用户的说明</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -g 组名： 手工指定用户的初始组</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -G 组名： 指定用户的附加组</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -s shell： 手工指定用户的登录shell。默认是/bin/bash</span> </span><br></pre></td></tr></tbody></table></figure><h3 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h3><p>修改密码</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">passwd [选项] 用户名</span><br><span class="line"><span class="meta">#</span><span class="bash"> -S  查询用户密码的密码状态。仅root用户可用。</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> -l  暂时锁定用户。仅root用户可用</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -u  解锁用户。仅root用户可用</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> --stdin 可以通过管道符输出的数据作为用户的密码。</span></span><br></pre></td></tr></tbody></table></figure><h3 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h3><p>修改用户信息</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">usermod [选项] 用户名</span><br><span class="line"><span class="meta">#</span><span class="bash"> -u UID：修改用户的UID号</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -c 用户说明：修改用户的说明信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -G 组名：修改用户的附加组</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -L：临时锁定用户（Lock）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -U：解锁用户锁定（Unlock）</span></span><br></pre></td></tr></tbody></table></figure><h3 id="chage"><a href="#chage" class="headerlink" title="chage"></a>chage</h3><p>修改用户信息</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chage [选项] 用户名</span><br><span class="line"><span class="meta">#</span><span class="bash"> -l：列出用户的详细密码状态</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 日期：修改密码最后一次更改日期（shadow3字段）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -m 天数：两次密码修改间隔（4字段）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -M 天数：密码有效期（5字段）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -W 天数：密码过期前警告天数（6字段）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -I 天数：密码过后宽限天数（7字段）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -E 日期：账号失效时间（8字段）</span></span><br></pre></td></tr></tbody></table></figure><h3 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h3><p>删除用户</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userdel [-r] 用户名 </span><br><span class="line"><span class="meta">#</span><span class="bash"> -r：删除用户的同时删除用户家目录</span> </span><br></pre></td></tr></tbody></table></figure><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>查看用户<strong>id</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id 用户名</span><br></pre></td></tr></tbody></table></figure><h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>切换用户</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su [选项] 用户名</span><br><span class="line"><span class="meta">#</span><span class="bash"> -：选项只使用“-”代表连带用户的环境变量一起切换  (env命令查看当前环境变量)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -c 命令：仅执行一次命令，而不切换用户身份</span></span><br></pre></td></tr></tbody></table></figure><h2 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h2><h4 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h4><p>添加组</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd [选项] 组名</span><br><span class="line"><span class="meta">#</span><span class="bash"> -g GID：指定组ID</span></span><br></pre></td></tr></tbody></table></figure><h4 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h4><p>修改组</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupmod [选项] 组名</span><br><span class="line"><span class="meta">#</span><span class="bash"> -g GID 修改组ID</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -n 新组名 修改组名</span></span><br></pre></td></tr></tbody></table></figure><h4 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h4><p>删除组</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel [选项] 组名</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">Linux用户管理配置，用户管理命令：用户信息文件、影子文件、组信息文件。</summary>
    
    
    
    <category term="Linux" scheme="https://1.15.86.100/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux-软件包管理</title>
    <link href="https://1.15.86.100/2021/08/14/Linux-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>https://1.15.86.100/2021/08/14/Linux-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/</id>
    <published>2021-08-14T07:57:13.000Z</published>
    <updated>2021-08-14T08:03:38.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h1><h2 id="软件包分类"><a href="#软件包分类" class="headerlink" title="软件包分类"></a>软件包分类</h2><h4 id="源码包"><a href="#源码包" class="headerlink" title="源码包"></a>源码包</h4><p>源码包的<strong>优点</strong>： </p><ul><li><p>开源，如果有足够的能力，可以修改源代码 ；</p></li><li><p>可以自由选择所需的功能 ；</p></li><li><p>软件是编译安装，所以更加适合自己的系统，更加稳定也效率更高 ；</p></li><li><p>卸载方便；</p></li></ul><p>源码包的<strong>缺点</strong>： </p><ul><li><p>安装过程步骤较多，尤其安装较大的软件集合时（如LAMP环境搭建），容易出现拼写错误；</p></li><li><p>编译过程时间较长，安装比二进制安装时间长 ；</p></li><li><p>因为是编译安装，安装过程中一旦报错新手很难解决；</p></li></ul><h4 id="RPM包（二进制）"><a href="#RPM包（二进制）" class="headerlink" title="RPM包（二进制）"></a>RPM包（二进制）</h4><p>二进制包的<strong>优点</strong> </p><ul><li><p>包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载 ；</p></li><li><p>安装速度比源码包安装快的多；</p></li></ul><p>二进制包<strong>缺点</strong>：</p><ul><li>经过编译，不再可以看到源代码； </li><li>功能选择不如源码包灵活 ；</li><li>依赖性；</li></ul>]]></content>
    
    
    <summary type="html">Linux软件包的介绍、安装等操作。</summary>
    
    
    
    <category term="Linux" scheme="https://1.15.86.100/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>TF-IDF</title>
    <link href="https://1.15.86.100/2021/08/12/TF-IDF/"/>
    <id>https://1.15.86.100/2021/08/12/TF-IDF/</id>
    <published>2021-08-12T09:16:06.000Z</published>
    <updated>2021-09-06T12:43:37.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>TF-IDF（Term Frequency-Inverse Document Frequency，词频-逆文档频率）</strong>算法，是信息检索中常用得统计算法。其主要目的是，反应文档或者语句中某些字词得重要程度。某篇文章中字词 <strong>A</strong> 的<strong>TF-IDF</strong>值随着 <strong>A</strong> 在该文档中出现的次数增多而增加，随着 <strong>A</strong> 在其他文档中出现的次数的增多而减少。</p><h2 id="TF"><a href="#TF" class="headerlink" title="TF"></a>TF</h2><p><strong>TF（Term Frequency）</strong>即词频，表示<strong>某个字词</strong>在某个文档中出现的次数占该文档中<strong>所有出现字词</strong>的比例。</p><h4 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h4><script type="math/tex; mode=display">\mathrm{tf}(t,d)=\frac{f_{t,d}}{\sum_{t'\in d}f_{t',d}}</script><p>其中：</p><ul><li><script type="math/tex">f_{t,d}</script>​：表示字词 <strong>t</strong> 在文档 <strong>d</strong> 中出现的次数；</li></ul><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>TF的值，<script type="math/tex">\mathrm{tf}(t,d)</script>​​ 还有其他<strong>定义方式</strong>：</p><ul><li>仅仅表示<strong>词频</strong>：<script type="math/tex">\mathrm{tf}(t,d)=f_{t,d}</script>；</li><li>布尔型：<script type="math/tex">\begin{equation}\mathrm{tf}(t,d)=\left\{ \begin{aligned} 1\ \ if\ t\in d\\ 0\ \ else \end{aligned} \right. \end{equation}</script>；​</li><li><strong>对数放缩</strong>：<script type="math/tex">\mathrm{tf}(t,d)=\log{(1+f_{t,d})}</script>；</li><li><strong>增强频率</strong>（避免长文档的偏差）​：<script type="math/tex">\mathrm{tf}(t,d)=0.5+0.5\cdot \frac{f_{t,d}}{\max{(f_{t',d}:t'\in d)}}</script>；</li></ul><h2 id="IDF"><a href="#IDF" class="headerlink" title="IDF"></a>IDF</h2><p><strong>IDF（Inverse Document Frequency）</strong>即<strong>逆文档频率</strong>，表示该字词的重要性，如果该字词在该文档出现频率高而很少出现在其他文档则表示该字词更重要。</p><h4 id="计算公式-1"><a href="#计算公式-1" class="headerlink" title="计算公式"></a>计算公式</h4><p><script type="math/tex">\mathrm{idf}(t,D)=\log{\frac{N}{|\{d\in D:t\in d\}|}}</script>​</p><p>其中：</p><ul><li><strong>N</strong>：表示<strong>语料库</strong>中<strong>文档</strong>总数：<script type="math/tex">N=|D|</script>；</li><li>其中：<script type="math/tex">|\{d\in D:t\in d\}|</script>​：包含 <strong>t</strong> 字词的文档个数；</li></ul><h4 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h4><ul><li>平滑<strong>IDF</strong>：<script type="math/tex">\mathrm{idf}(t,D)=\log{(\frac{N}{1+n_t})}+1</script>；</li><li>仅仅使用频率：<script type="math/tex">\mathrm{idf}(t,D)=N</script>；</li><li>最大<strong>IDF</strong>：<script type="math/tex">\mathrm{idf}(t,D)=\log{\frac{\max_{\{t'\in d\}}n_{t'}}{1+n_t}}</script>；</li><li>概率<strong>IDF</strong>：<script type="math/tex">\mathrm{idf}(t,D)=\log{\frac{N-n_t}{n_t}}</script>；</li></ul><h2 id="TF-IDF-1"><a href="#TF-IDF-1" class="headerlink" title="TF-IDF"></a>TF-IDF</h2><h4 id="计算公式-2"><a href="#计算公式-2" class="headerlink" title="计算公式"></a>计算公式</h4><p><script type="math/tex">\mathrm{tfidf}(t,d,D)=\mathrm{tf}(t,d)\cdot \mathrm{idf}(t, D)</script>；</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://en.wikipedia.org/wiki/Tf–idf">维基百科：TF-IDF</a></li></ul>]]></content>
    
    
    <summary type="html">对TF-IDF算法得介绍以及代码实现。</summary>
    
    
    
    <category term="NLP" scheme="https://1.15.86.100/categories/NLP/"/>
    
    
  </entry>
  
  <entry>
    <title>组合数学-整数拆分数</title>
    <link href="https://1.15.86.100/2021/08/12/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%E6%95%B0/"/>
    <id>https://1.15.86.100/2021/08/12/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%E6%95%B0/</id>
    <published>2021-08-12T08:04:10.000Z</published>
    <updated>2021-08-12T08:23:14.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整数拆分数"><a href="#整数拆分数" class="headerlink" title="整数拆分数"></a>整数拆分数</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>整数拆分</strong>即将一个整数拆分成其他整数（大于0）之和，要求计算其拆分种类个数。</p><h2 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h2><h3 id="欧拉方法"><a href="#欧拉方法" class="headerlink" title="欧拉方法"></a>欧拉方法</h3><p>令：<script type="math/tex">G(x)=(1+x+x^2+\cdots)(1+x^2+x^4+\cdots)\cdots(1+x^m+x^{2m}+\cdots)</script></p><p>则<strong>整数拆分数</strong>等于 <script type="math/tex">x^n</script> 的系数。</p><h3 id="Ferrers图"><a href="#Ferrers图" class="headerlink" title="Ferrers图"></a>Ferrers图</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><img src="/2021/08/12/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%E6%95%B0/image-20210812161257896.png" alt="image-20210812161257896"></p><p><img src="/2021/08/12/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%E6%95%B0/image-20210812161655726.png" alt="image-20210812161655726"></p><p><strong>Ferrers图像</strong>中，格子总数表示<strong>待拆分的整数</strong>，其格子按照行数<strong>从大到小</strong>的阶梯状排序，其<strong>列数</strong>表示拆分成的整数个数，其<strong>行数</strong>表示拆分成的整数值。</p><p>将<strong>Ferrers图像</strong>翻转的到的图像称为<strong>共轭Ferrers图像</strong>。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>整数 <strong>n</strong> 拆分成<strong>最大数为k</strong>的拆分数，和，拆分成<strong>k个数的和</strong>的拆分数是相等的。</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>利用<strong>Ferrers图像</strong>和<strong>共轭Ferrers图像</strong>可以证明。</p><h2 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h2><p><a href="https://www.bilibili.com/video/BV1vZ4y1j7gf?p=26">【学堂在线】组合数学_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <summary type="html">介绍整数拆分数以及Ferrers图像。</summary>
    
    
    
    <category term="组合数学" scheme="https://1.15.86.100/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>组合数学-母函数</title>
    <link href="https://1.15.86.100/2021/08/11/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-%E6%AF%8D%E5%87%BD%E6%95%B0/"/>
    <id>https://1.15.86.100/2021/08/11/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-%E6%AF%8D%E5%87%BD%E6%95%B0/</id>
    <published>2021-08-11T13:49:07.000Z</published>
    <updated>2021-08-11T14:13:12.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="母函数"><a href="#母函数" class="headerlink" title="母函数"></a>母函数</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>生成函数</strong>即<strong>母函数</strong>，是组合数学中尤其是计数方面的一个重要理论和工具。</p><ul><li>计数工具；</li><li>不考虑代数函数性质（收敛，极值）；</li><li>不在乎变量值；</li><li>母函数是将计数问题映射到函数多项式；</li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="掷骰子问题"><a href="#掷骰子问题" class="headerlink" title="掷骰子问题"></a>掷骰子问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><blockquote><p>求：投掷 <strong>m</strong> 个骰子，其点数之和为 <strong>n</strong> 的可能方式总数。</p></blockquote><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>令 <script type="math/tex">G(x)=(x+x^2+x^3+x^4+x^5+x^6)^m</script></p><p>则，其展开式中 <script type="math/tex">x^n</script> 前面的<strong>系数</strong>就是可能的方法数量。</p><h3 id="砝码称重问题"><a href="#砝码称重问题" class="headerlink" title="砝码称重问题"></a>砝码称重问题</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><blockquote><p>现在有 1g，2g，3g，4g 四个砝码，求能称重（只考虑砝码叠加）的数量多少？</p></blockquote><h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p><strong>母函数</strong>：<script type="math/tex">G(x)=(1+x)(1+x^2)(1+x^3)(1+x^4)</script></p><p>展开后有：<script type="math/tex">G(x)=1+x+x^2+2x^3+2x^4+2x^5+2x^6+2x^7+x^8+x^9+x^{10}</script></p><p>指数表示<strong>可以称重的克数</strong>，系数表示<strong>方案数</strong>。</p><h3 id="二进制称重"><a href="#二进制称重" class="headerlink" title="二进制称重"></a>二进制称重</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><blockquote><p>现在有 1g，2g，4g，8g 四个砝码，求能称重（只考虑砝码叠加）的数量多少？</p></blockquote><h4 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h4><p><strong>母函数</strong>：<script type="math/tex">G(x)=(1+x)(1+x^2)(1+x^4)(1+x^8)</script>​</p><p>展开后有：<script type="math/tex">G(x)=1+x+x^2+x^3+x^4+x^5+x^6+x^7+x^8+x^9+x^{10}+x^{11}+x^{12}+x^{13}+x^{14}+x^{15}</script></p><p><strong>系数</strong>都为1，所以可以发现：<strong>所有十进制整数都可以表示成唯一的二进制数</strong></p><h3 id="整数拆分问题"><a href="#整数拆分问题" class="headerlink" title="整数拆分问题"></a>整数拆分问题</h3><h4 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h4><blockquote><p>将整数 <strong>n</strong>，拆分成 1，2，3，……，m 的和，并允许重复</p></blockquote><h4 id="解决方法-3"><a href="#解决方法-3" class="headerlink" title="解决方法"></a>解决方法</h4><p><strong>母函数</strong>：<script type="math/tex">G(x)=(1+x+x^2+\cdots)(1+x^2+x^4+\cdots)\cdots(1+x^m+x^{2m}+\cdots)</script></p><h2 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h2><p><a href="https://www.bilibili.com/video/BV1vZ4y1j7gf?p=23&amp;spm_id_from=pageDriver">【学堂在线】组合数学_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <summary type="html">介绍母函数及其基本用法。</summary>
    
    
    
    <category term="组合数学" scheme="https://1.15.86.100/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>组合数学-全排列算法</title>
    <link href="https://1.15.86.100/2021/08/11/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/"/>
    <id>https://1.15.86.100/2021/08/11/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/</id>
    <published>2021-08-11T13:28:11.000Z</published>
    <updated>2021-08-11T13:49:37.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>给定 <script type="math/tex">{1,2,\cdots,n}</script>，共 <strong>n</strong> 个元素，求得所有的全排列结果。</p><h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><h2 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h2><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><ol><li>将原数据按从小到大排列，获得<strong>字典序</strong>最小的排列结果，记为：<script type="math/tex">x_1,x_2,\dots,x_n</script>；</li><li><strong>从右到左</strong>，找到第一次出现<strong>下降</strong>的位置，记为：<script type="math/tex">x_i</script>；</li><li>找出 <script type="math/tex">x_i</script> 后面比 <script type="math/tex">x_i</script><strong>大的最小</strong>的数 <script type="math/tex">x_j</script>；</li><li>交换 <script type="math/tex">x_i,x_j</script>；</li><li>将第 <script type="math/tex">i</script> 个位置后面的排列变成字典序最小的排列（升序排列）；</li><li>重复上述步骤，直到获得<strong>字典序最大</strong>排列（降序排列）</li></ol><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>获取 <strong>839647521</strong> 的下一个排列；</p><ol><li><strong>从左到右</strong>，<strong>1257</strong>都是升序，<strong>4</strong>是第一次下降；</li><li><strong>4</strong>后面的数中，<strong>5</strong>是大于<strong>4</strong>且最小的数；</li><li>交换 <strong>4</strong> 和 <strong>5</strong>，得到：<strong>839657421</strong>；</li><li>将 <strong>5</strong> 后面的序列 <strong>7421</strong> 变成最小字典序排列，即<strong>1247</strong>；</li><li>得到下一个排列：<strong>839651247</strong>；</li></ol><h2 id="SJT算法"><a href="#SJT算法" class="headerlink" title="SJT算法"></a>SJT算法</h2><h2 id="REF"><a href="#REF" class="headerlink" title="REF**"></a>REF**</h2><p><a href="https://www.bilibili.com/video/BV1vZ4y1j7gf?p=17">【学堂在线】组合数学_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <summary type="html">介绍生成全排列的方法，递归、字典序、SJT算法。</summary>
    
    
    
    <category term="组合数学" scheme="https://1.15.86.100/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>组合数学-排列组合</title>
    <link href="https://1.15.86.100/2021/08/11/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    <id>https://1.15.86.100/2021/08/11/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</id>
    <published>2021-08-11T08:00:21.000Z</published>
    <updated>2021-08-11T09:57:26.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h1><h2 id="多重排列"><a href="#多重排列" class="headerlink" title="多重排列"></a>多重排列</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>对于若干个元素，<script type="math/tex">r_1</script>个1，<script type="math/tex">r_2</script>个2，……<script type="math/tex">r_t</script>个t，元素个数之和为<strong>n</strong>，即<script type="math/tex">\sum_{i=1}^{t}r_i = n</script>​，那么其**全排列记为：<script type="math/tex">P(n;r_1,r_2,\cdots,r_t)</script>​。​</p><h4 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h4><script type="math/tex; mode=display">P(n;r_1,r_2,\cdots,r_t)=\frac{n!}{r_1!r_2!\cdots r_t!}</script><h2 id="无重组合"><a href="#无重组合" class="headerlink" title="无重组合"></a>无重组合</h2><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>从 <strong>n</strong> 个不同的元素中，取 <strong>r</strong> 个不重复的元素，组成一个子集，不考虑顺序，记为：<script type="math/tex">C(n,r)</script>​</p><h4 id="计算公式-1"><a href="#计算公式-1" class="headerlink" title="计算公式"></a>计算公式</h4><script type="math/tex; mode=display">C(n,r)=\frac{n!}{(n-r)!r!}</script><h2 id="无重排列"><a href="#无重排列" class="headerlink" title="无重排列"></a>无重排列</h2><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>从 <strong>n</strong> 个不同的元素中，取 <strong>r</strong> 个不重复的元素，按次序排列，记为：<script type="math/tex">P(n,r)</script></p><h4 id="计算公式-2"><a href="#计算公式-2" class="headerlink" title="计算公式"></a>计算公式</h4><script type="math/tex; mode=display">P(n,r)=\frac{n!}{(n-r)!}</script><h2 id="可重组合"><a href="#可重组合" class="headerlink" title="可重组合"></a>可重组合</h2><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>从n个不同的元素中，取r个元素，可以重复选取，记为：<script type="math/tex">\bar{C}(n,r)</script>​</p><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>取 <script type="math/tex">r</script>​ 个无标志的球，放入 <script type="math/tex">n</script>​​ 个有区别的盒子中，可以放0个或多余1个。</p><h4 id="计算公式-3"><a href="#计算公式-3" class="headerlink" title="计算公式"></a>计算公式</h4><script type="math/tex; mode=display">\bar{C}(n,r)=C(n+r-1, r)</script><h2 id="可重排列"><a href="#可重排列" class="headerlink" title="可重排列"></a>可重排列</h2><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>从n个不同的元素中，取r个进行排列，可以重复选取，记为：<script type="math/tex">P(n,r)</script></p><h4 id="计算公式-4"><a href="#计算公式-4" class="headerlink" title="计算公式"></a>计算公式</h4><script type="math/tex; mode=display">P(n,r)=n^r</script><h2 id="不相邻组合"><a href="#不相邻组合" class="headerlink" title="不相邻组合"></a>不相邻组合</h2><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>从<script type="math/tex">A=\{1,2,3,\cdots,n\}</script>中取<strong>r</strong>个不相邻的数进行组合，即不存在相邻的两个数<script type="math/tex">j,j+1</script>​的组合。</p><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><script type="math/tex; mode=display">C(n-r+1, r)</script><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>设<script type="math/tex">B=\{b_1,b_2,\cdots,b_r\}</script>是一组不相邻的组合；</p><p>让<strong>B</strong>序列元素分别减去其序号，构造<strong>C</strong>序列：<script type="math/tex">C=\{b_1-0,b_2-1,\cdots,b_r-(r-1)\}</script>​;</p><p>因为，<strong>B</strong>是不相邻的组合，所以：</p><script type="math/tex; mode=display">b_i<b_{i+1} - 1\to b_i-i+1<b_{i+1}-i+2</script><p>所以：</p><script type="math/tex; mode=display">c_1<c_2<\cdots c_r</script><p>又因为：<script type="math/tex">c_1=b_1-0\ge 1,c_r=b_r-r+1\le n-r+1</script></p><p>所以，组合数为：<script type="math/tex">C(n-r+1, r)</script>​</p><h4 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h4><p><a href="https://www.bilibili.com/video/BV1vZ4y1j7gf?p=22&amp;spm_id_from=pageDriver">【学堂在线】组合数学_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <summary type="html">排列组合基本概念公式、多重全排列等。</summary>
    
    
    
    <category term="组合数学" scheme="https://1.15.86.100/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="排列组合" scheme="https://1.15.86.100/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>SG函数</title>
    <link href="https://1.15.86.100/2021/07/14/SG%E5%87%BD%E6%95%B0/"/>
    <id>https://1.15.86.100/2021/07/14/SG%E5%87%BD%E6%95%B0/</id>
    <published>2021-07-14T09:15:40.000Z</published>
    <updated>2021-08-10T14:17:10.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SG-Sprague–Grundy-函数"><a href="#SG-Sprague–Grundy-函数" class="headerlink" title="SG(Sprague–Grundy)函数"></a>SG(Sprague–Grundy)函数</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在<strong>博弈论</strong>中，任何一个<strong>公平组合游戏</strong>都可以通过把每个<strong>局面（状态）</strong>看成一个<strong>顶点</strong>，对每个局面和它的子局面连一条有向边来抽象成一个<strong>有向图</strong>，游戏过程就是状态沿着顶点移动的过程，而<strong>SG函数</strong>就是定义在该<strong>有向图</strong>上的函数。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>组合游戏</strong>需要以下条件：</p><ul><li><p>游戏有且只有<strong>两个玩家</strong>；</p></li><li><p>游戏由两个玩家<strong>交替执行步骤</strong>，并且两位玩家都掌握<strong>完全信息</strong>。</p></li><li><p>游戏满足<strong>结束条件（ending condition）</strong>：</p><ul><li>所有的状态最终都会达到结束；</li><li>所有转移的步骤是有限的；</li></ul></li><li><p>游戏满足<strong>普通条件（normal play condition）</strong>：</p><p>  <strong>不能移动</strong>的玩家<strong>失败</strong>；</p></li></ul><h4 id="必胜点（P点）"><a href="#必胜点（P点）" class="headerlink" title="必胜点（P点）"></a>必胜点（P点）</h4><p>任何处于该点的玩家最终必胜；</p><h4 id="必败点（N点）"><a href="#必败点（N点）" class="headerlink" title="必败点（N点）"></a>必败点（N点）</h4><p>任何处于该点的玩家最终必败；</p><h4 id="相关性质"><a href="#相关性质" class="headerlink" title="相关性质"></a>相关性质</h4><ol><li>所有终结点是<strong>必败点</strong>；</li><li>从任何<strong>必胜点</strong>操作，至少有一种方式可以进入<strong>必败点</strong>；</li><li>无论如何操作，<strong>必败点</strong>只能进入<strong>必胜点</strong>；</li></ol><h3 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h3><h4 id="mex-minimal-excludant-运算"><a href="#mex-minimal-excludant-运算" class="headerlink" title="mex(minimal excludant)运算"></a>mex(minimal excludant)运算</h4><p>在集合上的一个运算，表示<strong>最小</strong>的<strong>不属于</strong>这个集合的<strong>非负整数</strong>。</p><p>例如：</p><ul><li>mex{0, 1, 2, 4} = 3；</li><li>mex{2, 4} = 0；</li><li>mex{} = 0；</li></ul><h4 id="SG-x-函数"><a href="#SG-x-函数" class="headerlink" title="SG(x)函数"></a>SG(x)函数</h4><p>对于任意状态<strong>x</strong>，<strong>SG(x) = mex(S)</strong>。</p><p>其中，<strong>S</strong>表示<strong>x</strong>后继状态的<strong>SG</strong>函数值的集合。</p><p>当<strong>SG函数值=0</strong>时，当前先手玩家必败，否则先手玩家必胜。</p><h4 id="取石子问题"><a href="#取石子问题" class="headerlink" title="取石子问题"></a>取石子问题</h4><blockquote><p>现在你有 <strong>n</strong> 个石子，每次可以取走 <script type="math/tex">a(a\in\{1,2\})</script>​​ 个，两个人轮流取，谁取完了谁就获胜，问先手是否必胜。</p></blockquote><p>首先，0个石子肯定是<strong>必败点</strong>，所以有：<script type="math/tex">SG(0)=0</script>；</p><p>有1个石子时，后继状态只有0，所以有：<script type="math/tex">SG(1) = mex\{SG(0)\}=1</script>；</p><p>有2个石子时，后继状态有0，1，所以有：<script type="math/tex">SG(2)=mex\{SG(1),SG(0)\}=2</script>​</p><p>有3个石子时，后继状态有1，2，所以有：<script type="math/tex">SG(3)=mex\{SG(1),SG(2)\}=0</script></p><p>有4个石子时，后继状态有2，3，所以有：<script type="math/tex">SG(4)=mex\{SG(2),SG(3)\}=1</script>​</p><p>有5个石子时，后继状态有3，4，所以有：<script type="math/tex">SG(5)=mex\{SG(3),SG(4)\}=2</script></p><p>有6个石子时，后继状态有4，5，所以有：<script type="math/tex">SG(6)=mex\{SG(4),SG(5)\}=0</script></p><p>……</p><p>容易发现：<script type="math/tex">SG(x)>0,if\ x>0</script>​，所以<strong>不一定先手必胜</strong>。</p><h3 id="证明（SG-0必败，否则必胜的证明）"><a href="#证明（SG-0必败，否则必胜的证明）" class="headerlink" title="证明（SG=0必败，否则必胜的证明）"></a>证明（SG=0必败，否则必胜的证明）</h3><p>首先，对于<strong>终结点</strong> <script type="math/tex">x</script>，此使令<script type="math/tex">SG(x)=0</script>，且必定属于<strong>必败点</strong>；</p><p>对于 <script type="math/tex">SG(x)= 0</script>​ 的<strong>非终结点</strong> <script type="math/tex">x</script>​：</p><ul><li>因为 <script type="math/tex">SG(x) =0</script>，所以，其<strong>子状态</strong>的<strong>SG值</strong>都不为0，即 <script type="math/tex">SG(y)\neq 0,if\ y\in\ sub(x)</script>；</li><li>而，对于<script type="math/tex">SG(y)\neq 0</script> 的状态 <script type="math/tex">y</script>​，其<strong>子状态集合</strong>中必包含<strong>SG值</strong>为0的状态，即 <script type="math/tex">\exist z,SG(z)=0,if\ z\in\ sub(y)</script>；</li><li>所以，处于 <script type="math/tex">x</script>​ 状态时，先手任意选择，后手选择<strong>到达 <script type="math/tex">z</script>状态</strong>的操作即可到达另一使先手<strong>SG值</strong>为0的状态；</li><li>又，该<strong>游戏图</strong>是<strong>有向无环图</strong>，且<strong>叶结点（终结点）</strong>都为必败点，所以<strong>SG=0</strong>的点必为必败点；</li></ul><p>对于 <script type="math/tex">SG(x) \neq 0</script>的点 <script type="math/tex">x</script>：</p><ul><li>其<strong>子状态集合</strong>中必包含<strong>SG值</strong>为0的状态，即 <script type="math/tex">\exist y,SG(y)=0,if\ y\in\ sub(x)</script>​​；</li><li>选择可以到达<strong>y</strong>状态的路径即可；</li></ul><h3 id="SG定理"><a href="#SG定理" class="headerlink" title="SG定理"></a>SG定理</h3><blockquote><p>游戏和的<strong>SG函数</strong>等于各个游戏SG函数值的<strong>Nim和</strong>。这样就可以将每一个子游戏<strong>分而治之</strong>，从而简化了问题。</p></blockquote><h4 id="Nim和"><a href="#Nim和" class="headerlink" title="Nim和"></a>Nim和</h4><p>将各个数<strong>异或</strong>的结果。</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><ul><li>设 <strong>#S</strong> 是所有子游戏的<strong>Nim和</strong>；</li><li>假设 <strong>#S</strong> 不为0，且最高位为1（假设为第 <strong>k</strong>位）的对应的其中一个子游戏的<strong>SG值</strong>为 <strong>#s</strong>；</li><li>令 <strong>#A</strong> 表示除去 <strong>#s</strong> 后，剩下的所有子游戏的 <strong>Nim和</strong>，则有：<strong>#S = #s ^ #A</strong>；</li><li>令 <strong>#a = #s ^ #S</strong>，既该轮的先手将一个子游戏的<strong>SG值</strong>由<strong>#s</strong>变为<strong>#a</strong>，因为<strong>#S，#s</strong>第 <strong>k</strong>位都为1，所以异或后为0，所以<strong>#a &lt; #s</strong>；</li><li>则有：<strong>#A ^ #a = #A ^ #s ^ #S = #A ^ #s ^ #s ^#A = 0</strong>；</li><li>综上如果 <strong>#S</strong> 不为0，先手总可以使 <strong>#S</strong>变为0，并且各堆的<strong>SG值</strong>是单调递减的，所以最终后手局时各堆 <strong>SG值</strong>都变为0，先手必胜；</li><li>同上如果 <strong>#S</strong>为0，先手必输；</li></ul><p><strong><a href="http://1.15.86.100:9000/Dilworth.pdf">REF</a></strong></p>]]></content>
    
    
    <summary type="html">对SG函数、SG定理的简述和证明。</summary>
    
    
    
    <category term="组合数学" scheme="https://1.15.86.100/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="Algorithm" scheme="https://1.15.86.100/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://1.15.86.100/2021/06/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://1.15.86.100/2021/06/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-06-05T08:34:22.000Z</published>
    <updated>2021-06-05T08:36:38.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><div class="table-container"><table><thead><tr><th>写法</th><th>描述</th></tr></thead><tbody><tr><td>[0-9]</td><td>匹配任何数字</td></tr><tr><td></td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">常用正则表达式。</summary>
    
    
    
    <category term="Python" scheme="https://1.15.86.100/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>卡特兰数</title>
    <link href="https://1.15.86.100/2021/05/26/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
    <id>https://1.15.86.100/2021/05/26/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/</id>
    <published>2021-05-26T11:58:21.000Z</published>
    <updated>2021-05-26T12:28:45.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>将<script type="math/tex">1,2,\cdots,N</script>，<strong>N</strong>个数依次进行入栈出栈操作，求输出的<strong>不同排列顺序的序列</strong>的个数。</p><p>假设<script type="math/tex">f(x)</script>表示<strong>x</strong>个数的序列个数，则对于<strong>N</strong>个数的数列，设<strong>i</strong>是最后出栈的数字，则比<strong>i</strong>小的数有<strong>i-1</strong>个，比<strong>i</strong>大的数有<strong>N-i</strong>个，所以<strong>递归公式</strong>为：</p><script type="math/tex; mode=display">f(N)=\sum_{i=1}^{N}f(i-1)\cdot f(N-i) \tag{*}</script><h2 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h2><script type="math/tex; mode=display">f(N)=\frac{4N-2}{n+1}f(N-1)</script><h2 id="通项公式"><a href="#通项公式" class="headerlink" title="通项公式"></a>通项公式</h2><script type="math/tex; mode=display">f(N)=\frac{C_{2N}^N}{N+1}</script>]]></content>
    
    
    <summary type="html">对卡特兰数的介绍。</summary>
    
    
    
    <category term="组合数学" scheme="https://1.15.86.100/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>RSA</title>
    <link href="https://1.15.86.100/2021/05/25/RSA/"/>
    <id>https://1.15.86.100/2021/05/25/RSA/</id>
    <published>2021-05-25T03:40:20.000Z</published>
    <updated>2021-08-01T08:53:11.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h1><p><strong>RSA</strong>是一种<strong>非对称加密</strong>方法。1977年由<em>Ron Rivest</em>、<em>Adi Shamir</em>和<em>Leonard Adleman</em>一起提出的。当时他们三人都在。RSA就是他们三人姓氏开头字母拼在一起组成的。</p><h3 id="欧拉函数-phi​"><a href="#欧拉函数-phi​" class="headerlink" title="欧拉函数\phi​"></a>欧拉函数<script type="math/tex">\phi</script>​</h3><p>欧拉函数<script type="math/tex">\phi(n)</script>表示从<script type="math/tex">1</script>到<script type="math/tex">n</script>中和<script type="math/tex">n</script>​互质的自然数的个数。</p><p>根据<strong>质数性质</strong>，有以下结论：</p><ul><li><script type="math/tex">\phi(1)=1</script>，因为<script type="math/tex">1</script>和<strong>任何数</strong>互质；</li><li><script type="math/tex">\phi(n)=n-1</script>，<script type="math/tex">n</script>为质数时，<script type="math/tex">n</script>和<script type="math/tex">1\cdots n-1</script>互质；</li></ul><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>如果两个正整数 <script type="math/tex">a</script> 和 <script type="math/tex">n</script> <strong>互质</strong>，则 <script type="math/tex">n</script> 的<strong>欧拉函数</strong> <script type="math/tex">\phi(n)</script> 可以让下面的等式成立：</p><script type="math/tex; mode=display">a^{\phi(n)}=1(\mod{n})</script><h2 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h2><h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><ul><li>随机选择两个<strong>不等</strong>的<strong>质数</strong> <script type="math/tex">p</script> 和 <script type="math/tex">q</script>；</li><li>计算 <script type="math/tex">p,q</script> 的<strong>乘积</strong> <script type="math/tex">n</script>​；【<strong>n</strong>做为<strong>公钥</strong>】</li><li>根据公式计算 <script type="math/tex">\phi(n)=LCM((p-1)(q-1))</script>​​，<strong>LCM</strong>：最小公倍数；</li><li>选择一个人整数<strong>e</strong>，满足：<script type="math/tex">1<e<\phi(n)\ and \ gcd(e,\phi(n))=1</script>​，即在<script type="math/tex">1</script>和<script type="math/tex">\phi(n)</script>之间和<script type="math/tex">\phi(n)</script>​互质的数；【<strong>e</strong>做为<strong>公钥</strong>】</li><li>令<script type="math/tex">d=e^{-1}(mod\ \phi(n))</script>；【<strong>d</strong>做为<strong>私钥</strong>】；</li></ul><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>待加密数据：<script type="math/tex">m</script>；</p><p>计算<strong>密文c</strong>：<script type="math/tex">c(\mod n)=m^e</script></p><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>密文：<script type="math/tex">c</script>；</p><p>计算<strong>原文m</strong>：<script type="math/tex">m(\mod n)=c^d</script></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ol><li>选择两个<strong>质数</strong>：<script type="math/tex">p=61,q=53</script>；</li><li>计算<strong>n</strong>：<script type="math/tex">n=p\cdot q=3233</script>；</li><li>计算欧拉函数：<script type="math/tex">\phi(n)=LCM((p-1)\cdot (q-1))=780</script>​；</li><li>随机取<strong>公钥</strong>（质数）：<script type="math/tex">e=17</script>；</li><li>计算<strong>私钥</strong>：<script type="math/tex">d=413,1=(17\times 413)(\mod780)</script>；</li><li>加密函数：<script type="math/tex">c(m)=m^{17}(\mod 3233)</script></li><li>解密函数：<script type="math/tex">m(c)=c^{413}(\mod 3233)</script></li></ol><h2 id="算法证明"><a href="#算法证明" class="headerlink" title="算法证明"></a>算法证明</h2><h3 id="基于欧拉定理"><a href="#基于欧拉定理" class="headerlink" title="基于欧拉定理"></a>基于欧拉定理</h3><p>对于和 <script type="math/tex">n</script> 互质的<strong>原文</strong>：<strong>m</strong>，需要证明：<script type="math/tex">m^{ed}=m(\mod n)</script></p><p>证明：</p><p>因为 <script type="math/tex">ed=1(\mod \phi(n))</script>​</p><p>有<script type="math/tex">ed=1+h\phi(n)</script></p><p>所以，<script type="math/tex">m^{ed}=m^{1+h\phi(n)}=m(m^{\phi(n)})^h</script>​​</p><p>根据<strong>欧拉定理</strong>：<script type="math/tex">m^{\phi(n)}=1(\mod n)</script></p><p>上式变为：<script type="math/tex">m(1)^h=m</script></p><p>故，原式得证。</p>]]></content>
    
    
    <summary type="html">对RSA加密算法的简单介绍。</summary>
    
    
    
    <category term="密码学" scheme="https://1.15.86.100/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="加密算法" scheme="https://1.15.86.100/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Dilworth定理</title>
    <link href="https://1.15.86.100/2021/05/24/Dilworth%E5%AE%9A%E7%90%86/"/>
    <id>https://1.15.86.100/2021/05/24/Dilworth%E5%AE%9A%E7%90%86/</id>
    <published>2021-05-24T12:04:37.000Z</published>
    <updated>2021-08-10T08:23:38.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dilworth定理"><a href="#Dilworth定理" class="headerlink" title="Dilworth定理"></a>Dilworth定理</h1><h2 id="概念定义"><a href="#概念定义" class="headerlink" title="概念定义"></a>概念定义</h2><ul><li><strong>自反性</strong>：对于集合<strong>A</strong>上的<strong>二元关系R</strong>，<script type="math/tex">xRx,\forall x\in A</script>；</li><li><strong>反对称性</strong>：对于集合<strong>A</strong>上的<strong>二元关系R</strong>，对于 <script type="math/tex">xRy\ \ and\ \ yRx,\forall x,y\in A</script>，有<script type="math/tex">x=y</script>；</li><li><strong>传递性</strong>：对于集合<strong>A</strong>上的<strong>二元关系R</strong>，对于 <script type="math/tex">xRy\ \ and\ \ yRz,\forall x,y,z\in A</script>，有<script type="math/tex">xRz</script>；</li><li><strong>偏序关系</strong>：满足<strong>自反性</strong>、<strong>反对称性</strong>、<strong>传递性</strong>的二元关系；</li><li><strong>偏序集</strong>：<script type="math/tex">(S,\precsim)</script>，集合<strong>S</strong>中任意两个元素之间都存在偏序关系；</li><li><strong>链</strong>：对于一个有序序列<script type="math/tex">(x_1,x_2,\cdots,x_n)</script>，如果<script type="math/tex">x_i\precsim x_j \forall i \le j</script>，则称该序列为<strong>链</strong>；</li><li><strong>反链</strong>：对于一个有序序列<script type="math/tex">(x_1,x_2,\cdots,x_n)</script>，如果<script type="math/tex">\forall i \le j,x_1,x_j</script>都不满足偏序关系<script type="math/tex">\precsim</script>（即不可比），则称该序列为<strong>反链</strong>；</li></ul><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><p>偏序集的<strong>最少</strong>的链的划分数等于其<strong>最长</strong>反链长度。</p><p>【把一个数列划分成最少的<strong>最长不升子序列</strong>的数目就等于这个数列的<strong>最长上升子序列</strong>的长度（LIS)】</p><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p><strong>数学归纳法</strong>：</p><p>设<strong>m</strong>表示<strong>偏序集</strong><script type="math/tex">(S,\precsim)</script>中元素个数。</p><ul><li><p>对于<strong>m=0，1</strong>，命题成立；</p></li><li><p>假设对于<script type="math/tex">m<n(n\in\mathbb{N}^+)</script>时命题成立，下面讨论<strong>m=n</strong>情况：</p><p>  设 <script type="math/tex">a</script> 为 <script type="math/tex">S</script> 中的一个<strong>极大元</strong>，构建偏序集 <script type="math/tex">S':=S-\{a\}</script>，由<strong>假设</strong>，<script type="math/tex">(S’,\precsim)</script> 满足该定理；</p><p>  假设 <script type="math/tex">S'</script> <strong>最小的链划分数</strong>以及<strong>最长反链长度</strong>为 <script type="math/tex">k</script>，划分为 <script type="math/tex">C_1,C_2\cdots,C_k</script> 这些不相交的链，长度为 <script type="math/tex">k</script> 的<strong>反链</strong>为 <script type="math/tex">a_1,a_2,\cdots,a_k</script>。</p><p>  记 <script type="math/tex">b_i</script> 为 <script type="math/tex">C_i</script> 中所有属于长为 <script type="math/tex">k</script> 的<strong>反链</strong>的元素中的<strong>最大元</strong>，构造<script type="math/tex">B:=\{b_1,b_2,\cdots,b_k\}</script>。在 <script type="math/tex">B</script> 中，易知 <script type="math/tex">B</script> 是<strong>反链</strong>，且 <script type="math/tex">C_i</script> 中的不可能存在多余一个元素都在<strong>反链</strong>上，也不会少于1个。</p><p>  下面考虑偏序集 <script type="math/tex">S</script>：</p><ul><li>因为 <script type="math/tex">a</script> 为 <script type="math/tex">S</script> 的<strong>极大元</strong>，那么 <script type="math/tex">\{a,b_1,b_2\cdots,b_k\}</script> 是一条长为 <script type="math/tex">k+1</script> 的<strong>反链</strong>。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">对Dilworth定理的介绍和证明。</summary>
    
    
    
    <category term="组合数学" scheme="https://1.15.86.100/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>以太网帧</title>
    <link href="https://1.15.86.100/2021/05/21/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7/"/>
    <id>https://1.15.86.100/2021/05/21/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7/</id>
    <published>2021-05-21T14:36:11.000Z</published>
    <updated>2021-05-30T08:37:11.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="以太帧"><a href="#以太帧" class="headerlink" title="以太帧"></a>以太帧</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在以太网<strong>链路层</strong>上的<strong>数据包</strong>称作<strong>以太帧</strong>。</p><p><strong>以太帧</strong>起始部分由<strong>前导码</strong>和<strong>帧开始符</strong>【802.3协议】组成。后面紧跟着一个以太网报头，以<strong>MAC地址</strong>说明目的地址和源地址。帧的中部是该帧负载的包含<strong>其他协议报头</strong>的数据包（例如IP协议）。以太帧由一个32位<strong>冗余校验码</strong>结尾。它用于检验数据传输是否出现损坏。</p><p><strong>前导码</strong>用于引起接受节点的注意，实质是告诉接收方准备接受新帧。</p><p>相关的有<strong>Ethernet II</strong>、<strong>802.2 LLC</strong>等协议。</p><h2 id="Ethernet-II"><a href="#Ethernet-II" class="headerlink" title="Ethernet II"></a>Ethernet II</h2><p><img src="/2021/05/21/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7/700px-Ethernet_Type_II_Frame_format.svg.png" alt="img"></p><ul><li><strong>目的硬件地址（Destination MAC Address）</strong>：占 48 bit；</li><li><strong>源硬件地址（Source MAC Address）</strong>：占 48 bit；</li><li><strong>以太类型（Type）</strong>：占 16 bit；</li><li><strong>数据（Data）</strong>：上一层传递的数据；标识封装于<strong>以太网帧</strong>中的上层协议，常见值为16进制：<ul><li>0x800：IPv4；</li><li>0x86DD：IPv6；</li><li>0x806：ARP；</li></ul></li><li><strong>循环校验和（CRC Checksum）</strong>：占 32 bit，进行数据校验；</li></ul>]]></content>
    
    
    <summary type="html">对链路层的以太帧介绍。</summary>
    
    
    
    <category term="Computer Network" scheme="https://1.15.86.100/categories/Computer-Network/"/>
    
    
    <category term="Ethernet II" scheme="https://1.15.86.100/tags/Ethernet-II/"/>
    
  </entry>
  
</feed>
