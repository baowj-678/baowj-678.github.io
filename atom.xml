<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BaoWJ&#39;s Blog</title>
  
  
  <link href="https://1.15.86.100/atom.xml" rel="self"/>
  
  <link href="https://1.15.86.100/"/>
  <updated>2021-08-18T14:15:14.300Z</updated>
  <id>https://1.15.86.100/</id>
  
  <author>
    <name>Bao Wenjie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux-系统管理</title>
    <link href="https://1.15.86.100/2021/08/18/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    <id>https://1.15.86.100/2021/08/18/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</id>
    <published>2021-08-18T12:48:21.000Z</published>
    <updated>2021-08-18T14:15:14.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux系统管理"><a href="#Linux系统管理" class="headerlink" title="Linux系统管理"></a>Linux系统管理</h1><h2 id="软件管理"><a href="#软件管理" class="headerlink" title="软件管理"></a>软件管理</h2><h4 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install 软件名</span><br></pre></td></tr></tbody></table></figure><h4 id="软件卸载"><a href="#软件卸载" class="headerlink" title="软件卸载"></a>软件卸载</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt remove 软件名</span><br></pre></td></tr></tbody></table></figure><h4 id="更新安装包"><a href="#更新安装包" class="headerlink" title="更新安装包"></a>更新安装包</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt upgrade</span><br></pre></td></tr></tbody></table></figure><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><p>查看所有进程</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ps [选项]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -aux：查看系统中所有进程，使用BSD操作系统格式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -le：查看系统中所有进程，使用Linux标准命令格式</span></span><br><span class="line"></span><br><span class="line">pstree [选项]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示进程树</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p：显示进程的PID</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -u：显示进程的所属用户</span></span><br></pre></td></tr></tbody></table></figure><p><img src="/2021/08/18/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/image-20210818210901189.png" alt="image-20210818210901189"></p><ul><li><p><strong>USER</strong>：该进程是由哪个用户产生的；</p></li><li><p><strong>PID</strong>：进程的ID号；</p></li><li><p><strong>%CPU</strong>：该进程占用CPU资源的百分比，占用越高，进程越耗费资源；</p></li><li><p><strong>%MEN</strong>：该进程占用物理内存的百分比，占用越高，进程越耗费资源；</p></li><li><p><strong>VSZ</strong>: 该进程占用虚拟内存的大小，单位KB；</p></li><li><p><strong>RSS</strong>：该进程占用实际物理内存的大小，单位KB；</p></li><li><p><strong>TTY</strong>：该进程是在哪个终端中运行的。其中tty1-tty7代表本地控制台终端，tty1-tty6是本地的字符界面终端，tty7 是图形终端。pts/0-255代表虚拟终端；</p></li><li><p><strong>STAT</strong>：进程状态。常见的状态有：</p></li><li><ul><li>R：运行<ul><li>S：睡眠</li><li>T：停止状态</li><li>s：包含子进程</li><li>+：位于后台 </li></ul></li></ul></li><li><p><strong>START</strong>：该进程的启动时间；</p></li><li><p><strong>TIME</strong>：该进程占用CPU的运算时间，注意不是系统时间；</p></li><li><p><strong>COMMAND</strong>：产生此进程的命令名；</p></li></ul><h4 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kill -l</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看可用的进程信号</span></span><br><span class="line"></span><br><span class="line">kill -9 pid</span><br><span class="line"><span class="meta">#</span><span class="bash"> 杀死进程</span></span><br><span class="line"></span><br><span class="line">killall [选项][信号] 进程名 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照进程名杀死进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -i：交互式，询问是否要杀死某个进程</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -I：忽略进程名的大小写</span>  </span><br><span class="line"></span><br><span class="line">pkill [选项] [信号] 进程名 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照进程名终止进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t 终端号：按照终端号踢出用户</span></span><br></pre></td></tr></tbody></table></figure><h4 id="进程后台运行"><a href="#进程后台运行" class="headerlink" title="进程后台运行"></a>进程后台运行</h4><ul><li><p><code>&amp;</code>：在命令后面加上 <code>&amp;</code>；</p>  <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nuhup [命令] $</span><br></pre></td></tr></tbody></table></figure></li><li><p>查看后台进程</p>  <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobs -l</span><br></pre></td></tr></tbody></table></figure></li><li><p>将后台暂停的工作恢复到前台执行；</p>  <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fg %工作号</span><br><span class="line"><span class="meta">#</span><span class="bash"> %工作号：%号可以省略，但是注意工作号和PID的区别</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>把后台暂停的工作恢复到后台执行；</p>  <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bg %工作号</span><br><span class="line"><span class="meta">#</span><span class="bash"> 后台恢复执行的命令，是不能和前台有交互的，否则不能恢复到后台执行。</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 杀死当前bash内运行的进程</span></span><br><span class="line">Ctrl+c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂起当前bash内运行的进程</span></span><br><span class="line">Ctrl+z</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行刚刚挂起的进程</span></span><br><span class="line">Ctrl+y</span><br></pre></td></tr></tbody></table></figure><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><h4 id="查看系统健康状态"><a href="#查看系统健康状态" class="headerlink" title="查看系统健康状态"></a>查看系统健康状态</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">top [ 选项] </span><br><span class="line"><span class="meta">#</span><span class="bash"> -d  秒数：指定top命令每隔几秒更新。默认是3秒 在top命令的交互模式当中可以执行的命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ?或h：显示交互模式的帮助</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> P：以CPU使用率排序，默认就是此项</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> M：以内存的使用率排序</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> N：以PID排序</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> q：退出top</span></span><br></pre></td></tr></tbody></table></figure><h4 id="查看系统资源"><a href="#查看系统资源" class="headerlink" title="查看系统资源"></a>查看系统资源</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat [刷新延时] [刷新次数]  </span><br></pre></td></tr></tbody></table></figure><h4 id="查看开机时内核检测信息"><a href="#查看开机时内核检测信息" class="headerlink" title="查看开机时内核检测信息"></a>查看开机时内核检测信息</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dmesg </span><br><span class="line">dmesg | grep CPU</span><br></pre></td></tr></tbody></table></figure><h4 id="查看内存使用状态"><a href="#查看内存使用状态" class="headerlink" title="查看内存使用状态"></a>查看内存使用状态</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">free [选项]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -b：以字节为单位显示</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -k：以KB为单位显示，默认就是以KB为单位显示</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -m：以MB为单位显示</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -g：以GB为单位显示</span></span><br></pre></td></tr></tbody></table></figure><h4 id="查看CPU信息"><a href="#查看CPU信息" class="headerlink" title="查看CPU信息"></a>查看CPU信息</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></tbody></table></figure><p><img src="/2021/08/18/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/image-20210818214146172.png" alt="image-20210818214146172"></p><h4 id="查看系统与内核相关信息"><a href="#查看系统与内核相关信息" class="headerlink" title="查看系统与内核相关信息"></a>查看系统与内核相关信息</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uname [选项]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -a：查看系统所有相关信息；</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -r：查看内核版本；</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -s：查看内核名称。</span> </span><br></pre></td></tr></tbody></table></figure><p><img src="/2021/08/18/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/image-20210818214302083.png" alt="image-20210818214302083"></p><h4 id="查看当前系统的位数"><a href="#查看当前系统的位数" class="headerlink" title="查看当前系统的位数"></a>查看当前系统的位数</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file /bin/ls</span><br></pre></td></tr></tbody></table></figure><h4 id="查询当前Linux系统的发行版本"><a href="#查询当前Linux系统的发行版本" class="headerlink" title="查询当前Linux系统的发行版本"></a>查询当前Linux系统的发行版本</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></tbody></table></figure><h4 id="查看进程打开或使用的文件信息"><a href="#查看进程打开或使用的文件信息" class="headerlink" title="查看进程打开或使用的文件信息"></a>查看进程打开或使用的文件信息</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsof [选项]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -c  字符串：只列出以字符串开头的进程打开的文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -u  用户名：只列出某个用户的进程打开的文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p  pid：列出某个PID进程打开的文件</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">Linux系统管理。</summary>
    
    
    
    <category term="Linux" scheme="https://1.15.86.100/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo-多设备配置</title>
    <link href="https://1.15.86.100/2021/08/18/Hexo-%E5%A4%9A%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    <id>https://1.15.86.100/2021/08/18/Hexo-%E5%A4%9A%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/</id>
    <published>2021-08-18T03:44:57.000Z</published>
    <updated>2021-08-18T12:29:28.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-多设备配置"><a href="#Hexo-多设备配置" class="headerlink" title="Hexo-多设备配置"></a>Hexo-多设备配置</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h2 id="git服务器配置"><a href="#git服务器配置" class="headerlink" title="git服务器配置"></a>git服务器配置</h2><h2 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h2><h2 id="其他设备配置-ubuntu"><a href="#其他设备配置-ubuntu" class="headerlink" title="其他设备配置(ubuntu)"></a>其他设备配置(ubuntu)</h2><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo install npm</span><br><span class="line"></span><br><span class="line">npm install hexo</span><br></pre></td></tr></tbody></table></figure><h3 id="克隆文件仓库"><a href="#克隆文件仓库" class="headerlink" title="克隆文件仓库"></a>克隆文件仓库</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone ubuntu@1.15.86.100:/hexo/GitLibrary/data.git</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">利用git仓库保存hexo文件，可以在多个设备编辑博客并实现同步。</summary>
    
    
    
    <category term="blog" scheme="https://1.15.86.100/categories/blog/"/>
    
    
    <category term="Hexo" scheme="https://1.15.86.100/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Linux-Shell编程</title>
    <link href="https://1.15.86.100/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/"/>
    <id>https://1.15.86.100/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/</id>
    <published>2021-08-16T15:07:12.000Z</published>
    <updated>2021-08-18T12:29:28.145Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell简介"><a href="#Shell简介" class="headerlink" title="Shell简介"></a>Shell简介</h1><h2 id="Shell简介-1"><a href="#Shell简介-1" class="headerlink" title="Shell简介"></a>Shell简介</h2><h3 id="Shell是什么"><a href="#Shell是什么" class="headerlink" title="Shell是什么"></a>Shell是什么</h3><ul><li>Shell是一个<strong>命令行解释器</strong>，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序；</li><li>Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。Shell是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令；</li></ul><h3 id="Shell分类"><a href="#Shell分类" class="headerlink" title="Shell分类"></a>Shell分类</h3><ul><li><p><strong>Bourne Shell</strong>：从1979起Unix就开始使用Bourne Shell，Bourne Shell的主文件名为<strong>sh</strong>，Bourne家族主要包括sh、ksh、<strong>Bash</strong>、psh、zsh；</p></li><li><p><strong>C Shell</strong>： C Shell主要在BSD版的Unix系统中使用，其语法和C语言相类似而得名，C家族主要包括：csh、tcsh；</p></li><li><strong>Bash</strong>： Bash与sh兼容，现在使用的Linux 就是使用Bash作为用户的基本Shell；</li></ul><h3 id="查看Linux支持的shell"><a href="#查看Linux支持的shell" class="headerlink" title="查看Linux支持的shell"></a>查看Linux支持的shell</h3><p><code>/etc/shells</code></p><p><img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/image-20210816231159818.png" alt="image-20210816231159818"></p><h2 id="Bash基本功能"><a href="#Bash基本功能" class="headerlink" title="Bash基本功能"></a>Bash基本功能</h2><h3 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h3><ul><li>直接运行：<code>./hello.sh</code>；</li><li>Bash调用执行脚本：<code>bash hello.sh</code>，<code>sh hello.sh</code>；</li></ul><h3 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo [选项] [输出内容]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -e： 支持反斜线控制的字符转换</span></span><br></pre></td></tr></tbody></table></figure><h3 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h3><p><code>history</code></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">history [选项] [历史命令保存文件]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -c：清空历史命令</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -w：把缓存中的历史命令写入历史命令保存文件，保存在：~/.bash_history</span> </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h3><h4 id="设置别名-1"><a href="#设置别名-1" class="headerlink" title="设置别名"></a>设置别名</h4><p><code>alias 别名='原命令'</code></p><h4 id="删除别名"><a href="#删除别名" class="headerlink" title="删除别名"></a>删除别名</h4><p><code>unalias 别名</code></p><h4 id="查看别名"><a href="#查看别名" class="headerlink" title="查看别名"></a>查看别名</h4><p><code>alias</code></p><h3 id="命令执行顺序"><a href="#命令执行顺序" class="headerlink" title="命令执行顺序"></a>命令执行顺序</h3><p>1 第一顺位执行用绝对路径或相对路径执行的命令；</p><p>2 第二顺位执行别名；</p><p>3 第三顺位执行Bash的内部命令； </p><p>4 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令；</p><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>​                 <img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/1.png" alt="img">        </p><p>​                 <img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/2.png" alt="img">        </p><h3 id="多命令与管道"><a href="#多命令与管道" class="headerlink" title="多命令与管道"></a>多命令与管道</h3><p>​                 <img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/3.png" alt="img">        </p><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p><code>命令1  |  命令2</code></p><p>命令1的正确输出作为命令2的操作对象</p><h3 id="通配符与特殊符号"><a href="#通配符与特殊符号" class="headerlink" title="通配符与特殊符号"></a>通配符与特殊符号</h3><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>​                 <img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/4.png" alt="img">        </p><h4 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h4><p>​                 <img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/5.png" alt="img">        </p><h3 id="Bash的变量"><a href="#Bash的变量" class="headerlink" title="Bash的变量"></a>Bash的变量</h3><h4 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name="bwj"</span><br></pre></td></tr></tbody></table></figure><h4 id="变量调用"><a href="#变量调用" class="headerlink" title="变量调用"></a>变量调用</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $name</span><br></pre></td></tr></tbody></table></figure><h4 id="变量查看"><a href="#变量查看" class="headerlink" title="变量查看"></a>变量查看</h4><p>查看Bash所有变量</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set</span><br></pre></td></tr></tbody></table></figure><h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset [变量名]</span><br></pre></td></tr></tbody></table></figure><h3 id="Bash运算符"><a href="#Bash运算符" class="headerlink" title="Bash运算符"></a>Bash运算符</h3><h4 id="声明变量类型"><a href="#声明变量类型" class="headerlink" title="声明变量类型"></a>声明变量类型</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">declare [+/-][选项] 变量名</span><br><span class="line"><span class="meta">#</span><span class="bash"> -：给变量设定类型属性</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> +：取消变量的类型属性</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -i：将变量声明为整数型（<span class="built_in">integer</span>）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -x：将变量声明为环境变量</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p：显示指定变量的被声明的类型</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">declare</span> -i cc=<span class="variable">$aa</span>+<span class="variable">$bb</span></span></span><br></pre></td></tr></tbody></table></figure><h4 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h4><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p><code>declare -i cc=$aa+$bb</code></p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p><strong>expr或let数值运算工具</strong></p><p> <code>dd=$(expr $​aa + $bb)</code></p><ul><li>dd的值是aa和bb的和。注意“+”号左右两侧必须有空格；</li></ul><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p><strong>“$((运算式))”或“$[运算式]”</strong></p><p><code>ff=$(( $aa+$bb ))</code></p><p><code>gg=$[ $aa+$bb ]</code></p><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>​                 <img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/9.png" alt="img"></p><pre><code>  #### 变量测试与内容替换 </code></pre><p><img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/10.png" alt="img"></p><p>​        </p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p><code>export 变量名=变量值</code> </p><h4 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h4><p><code>env</code> </p><h4 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h4><p><code>unset 变量名</code></p><h4 id="添加PATH"><a href="#添加PATH" class="headerlink" title="添加PATH"></a>添加PATH</h4><p><code>PATH="$PATH":/root/sh</code>【重启会消失】</p><h4 id="系统提示符"><a href="#系统提示符" class="headerlink" title="系统提示符"></a>系统提示符</h4><p>定义系统提示符（例如：<code>ubuntu@VM-0-2-ubuntu:~$</code>）的变量：<code>PS1</code> </p><ul><li><p><strong>\d</strong>：显示日期，格式为“星期 月 日”；</p></li><li><p><strong>\h</strong>：显示简写主机名。如默认主机名“localhost” ；</p></li><li><p><strong>\t</strong>：显示24小时制时间，格式为“HH:MM:SS” ；</p></li><li><p><strong>\T</strong>：显示12小时制时间，格式为“HH:MM:SS”；</p></li><li><p><strong>\A</strong>：显示24小时制时间，格式为“HH:MM” ；</p></li><li><p><strong>\u</strong>：显示当前用户名；</p></li><li><p><strong>\w</strong>：显示当前所在目录的完整名称；</p></li><li><p><strong>\W</strong>：显示当前所在目录的最后一个目录；</p></li><li><p><strong>#</strong>：执行的第几个命令；</p></li><li><p><strong>$</strong>：提示符。如果是root用户会显示提示符为“#”，如果是普通用户会显示提示符为“$”；</p></li></ul><h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><h4 id="配置文件简介"><a href="#配置文件简介" class="headerlink" title="配置文件简介"></a>配置文件简介</h4><p>环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量，比如<strong>PATH、HISTSIZE、PS1、HOSTNAME</strong>等默认环境变量。</p><ul><li>/etc/profile </li><li>/etc/profile.d/*.sh </li><li>~/.bash_profile </li><li>~/.bashrc </li><li>/etc/bashrc</li></ul><h4 id="环境变量配置文件调用顺序"><a href="#环境变量配置文件调用顺序" class="headerlink" title="环境变量配置文件调用顺序"></a>环境变量配置文件调用顺序</h4><p>​                 <img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/11.png" alt="img"> </p><h4 id="etc-profile的作用"><a href="#etc-profile的作用" class="headerlink" title="/etc/profile的作用"></a>/etc/profile的作用</h4><ul><li><strong>USER</strong>变量；</li><li><strong>LOGNAME</strong>变量；</li><li><strong>MAIL</strong>变量；</li><li><strong>PATH</strong>变量；</li><li><strong>HOSTNAME</strong>变量；</li><li><strong>HISTSIZE</strong>变量；</li><li><strong>umask</strong>；</li><li>调用<strong>/etc/profile.d/*.sh</strong>文件；</li></ul><h4 id="bash-history"><a href="#bash-history" class="headerlink" title="~/bash_history"></a>~/bash_history</h4><p>历史命令</p><h4 id="重新加载配置文件"><a href="#重新加载配置文件" class="headerlink" title="重新加载配置文件"></a>重新加载配置文件</h4><p><code>source 配置文件</code></p><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><p>​                 <img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/6.png" alt="img"> </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 加法程序</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">num1=$1</span><br><span class="line">num2=$2</span><br><span class="line">sum=$(($num1 + $num2))</span><br><span class="line">echo $sum</span><br></pre></td></tr></tbody></table></figure><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><h4 id="预定义变量-1"><a href="#预定义变量-1" class="headerlink" title="预定义变量"></a>预定义变量</h4><p>​                 <img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/8.png" alt="img"></p><h4 id="接收键盘输入"><a href="#接收键盘输入" class="headerlink" title="接收键盘输入"></a>接收键盘输入</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read [选项] [变量名]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -p “提示信息”：在等待<span class="built_in">read</span>输入时，输出提示信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t 秒数：<span class="built_in">read</span>命令会一直等待用户输入，使用此选项可以指定等待时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -n 字符数：<span class="built_in">read</span>命令只接受指定的字符数，就会执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -s：隐藏输入的数据，适用于机密信息的输入</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h2><h3 id="比较判断"><a href="#比较判断" class="headerlink" title="比较判断"></a>比较判断</h3><h4 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test [] /root/install.log</span><br><span class="line"></span><br><span class="line">[ [选项] /root/install.log ]</span><br></pre></td></tr></tbody></table></figure><h4 id="按照文件类型"><a href="#按照文件类型" class="headerlink" title="按照文件类型"></a>按照文件类型</h4><p><img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/13.png" alt=""></p><h4 id="按照文件权限判断"><a href="#按照文件权限判断" class="headerlink" title="按照文件权限判断"></a>按照文件权限判断</h4><p><img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/14.png" alt=""></p><h4 id="两个文件之间进行比较"><a href="#两个文件之间进行比较" class="headerlink" title="两个文件之间进行比较"></a>两个文件之间进行比较</h4><p><img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/15.png" alt=""></p><h4 id="整数比较"><a href="#整数比较" class="headerlink" title="整数比较"></a>整数比较</h4><p><img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/16.png" alt=""></p><h4 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断"></a>字符串判断</h4><p><img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/17.png" alt=""></p><h4 id="多重条件判断"><a href="#多重条件判断" class="headerlink" title="多重条件判断"></a>多重条件判断</h4><p><img src="/2021/08/16/Linux-Shell%E7%BC%96%E7%A8%8B/18.png" alt=""></p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ];then</span><br><span class="line">程序</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################</span></span></span><br><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">程序</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################</span></span></span><br><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">程序</span><br><span class="line">elif [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">程序</span><br><span class="line">else</span><br><span class="line">程序</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure><h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">case "$变量名" in  </span><br><span class="line">    "值1")</span><br><span class="line">         如果变量的值等于值1，则执行程序1</span><br><span class="line">; ;</span><br><span class="line">    "值2")   </span><br><span class="line">         如果变量的值等于值2，则执行程序2  </span><br><span class="line">; ;  </span><br><span class="line">      …省略其他分支…  </span><br><span class="line">*)</span><br><span class="line">      如果变量的值都不是以上的值，则执行此程序 </span><br><span class="line">; ;</span><br><span class="line">esac</span><br></pre></td></tr></tbody></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3</span><br><span class="line">    do </span><br><span class="line">        程序</span><br><span class="line">    done</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################</span></span></span><br><span class="line">for((初始值;循环控制条件;变量变化))</span><br><span class="line">    do</span><br><span class="line">        程序</span><br><span class="line">    done</span><br></pre></td></tr></tbody></table></figure><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">    do</span><br><span class="line">        程序</span><br><span class="line">    done</span><br></pre></td></tr></tbody></table></figure><h4 id="until"><a href="#until" class="headerlink" title="until"></a>until</h4><p>until循环，和while循环相反，until循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until [ 条件判断式 ]</span><br><span class="line">    do</span><br><span class="line">        程序</span><br><span class="line">    done</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">Shell编程的语法。</summary>
    
    
    
    <category term="Linux" scheme="https://1.15.86.100/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux-文件系统管理</title>
    <link href="https://1.15.86.100/2021/08/16/Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    <id>https://1.15.86.100/2021/08/16/Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</id>
    <published>2021-08-16T02:31:13.000Z</published>
    <updated>2021-08-16T03:12:49.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-文件系统管理"><a href="#Linux-文件系统管理" class="headerlink" title="Linux 文件系统管理"></a>Linux 文件系统管理</h1><h2 id="分区和文件系统"><a href="#分区和文件系统" class="headerlink" title="分区和文件系统"></a>分区和文件系统</h2><h3 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h3><ul><li><strong>主分区</strong>：总共最多只能分<strong>四</strong>个；</li><li><p><strong>扩展分区</strong>：只能有一个，也算作主分区的一种，也就是说<strong>主分区加扩展分区最多有四个</strong>。但是扩展分区不能存储数据和格式化，必须再划分成逻辑分区才能使用；</p></li><li><p><strong>逻辑分区</strong>：逻辑分区是在扩展分区中划分的，如果是IDE硬盘，Linux最多支持59个逻辑分区，如果是SCSI硬盘Linux最多支持11个逻辑分区；</p></li></ul><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ul><li><strong>ext2</strong>：是ext文件系统的升级版本，Red Hat Linux7.2版本以前的系统默认都是ext2 文件系统。1993年发布，<strong>最大支持16TB 的分区和最大2TB的文件</strong>（1TB=1024GB=1024*1024KB）；</li><li><strong>ext3</strong>： ext3文件系统是ext2文件系统的升级版本，最大的区别就是<strong>带日志功能</strong>，以在系统突然停止时提高文件系统的可靠性。支持最大16TB的分区和最大2TB的文件；</li><li><strong>ext4</strong>：它是ext3文件系统的升级版。ext4 在性能、伸缩性和可靠性方面进行了大量改进。EXT4 的变化可以说是翻天覆地的，比如向下兼容EXT3、<strong>最大1EB文件系统和16TB文件</strong>、无限数量子目录、Extents连续数据块概念、多块分配、延迟分配、持久预分配、快速FSCK、日志校验、无日志模式、在线碎片整理、inode增强、默认启用barrier等。是CentOS 6.3的默认文件系统      （1EB=1024PB=1024*1024TB）；</li></ul><h2 id="文件系统常用命令"><a href="#文件系统常用命令" class="headerlink" title="文件系统常用命令"></a>文件系统常用命令</h2><h3 id="普通命令"><a href="#普通命令" class="headerlink" title="普通命令"></a>普通命令</h3><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>查看文件系统</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df  [选项] [挂载点]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -a：显示所有的文件系统信息，包括特殊文件系统，如 /proc、/sysfs</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -h：使用习惯单位显示容量，如KB，MB或GB等</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -T：显示文件系统类型</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -m：以MB为单位显示容量</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -k：以KB为单位显示容量。默认就是以KB为单位</span></span><br></pre></td></tr></tbody></table></figure><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><p>统计目录或文件大小</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">du [选项] [目录或文件名]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -a：显示每个子文件的磁盘占用量。默认只统计 子目录的磁盘占用量</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -h：使用习惯单位显示磁盘占用量，如KB，MB  或GB等</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -s：统计总占用量，而不列出子目录和子文件的 占用量</span></span><br></pre></td></tr></tbody></table></figure><h4 id="fsck"><a href="#fsck" class="headerlink" title="fsck"></a>fsck</h4><p>文件系统修复命令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fsck [选项] 分区设备文件名</span><br><span class="line"><span class="meta">#</span><span class="bash"> -a：不用显示用户提示，自动修复文件系统；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -y：自动修复。和-a作用一致，不过有些文件系统只支持-y</span></span><br></pre></td></tr></tbody></table></figure><h4 id="dumpe2fs"><a href="#dumpe2fs" class="headerlink" title="dumpe2fs"></a>dumpe2fs</h4><p>显示磁盘状态</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpe2fs 分区设备文件名</span><br></pre></td></tr></tbody></table></figure><h3 id="挂载命令"><a href="#挂载命令" class="headerlink" title="挂载命令"></a>挂载命令</h3><h4 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount [选项]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -l：查询系统中已经挂载的设备，会显示卷标名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> –a：依据配置文件/etc/fstab的内容，自动挂载</span></span><br></pre></td></tr></tbody></table></figure><p>~~~shell<br>mount [-t 文件系统] [-L 卷标名]  [-o 特殊选项]  设备文件名 挂载点</p><h1 id="t-文件系统：加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660等文件系统"><a href="#t-文件系统：加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660等文件系统" class="headerlink" title="-t 文件系统：加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660等文件系统"></a>-t 文件系统：加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660等文件系统</h1><h1 id="L-卷标名：-挂载指定卷标的分区，而不是安装设备文件名挂载"><a href="#L-卷标名：-挂载指定卷标的分区，而不是安装设备文件名挂载" class="headerlink" title="-L 卷标名： 挂载指定卷标的分区，而不是安装设备文件名挂载"></a>-L 卷标名： 挂载指定卷标的分区，而不是安装设备文件名挂载</h1><h1 id="o-特殊选项：可以指定挂载的额外选项"><a href="#o-特殊选项：可以指定挂载的额外选项" class="headerlink" title="-o 特殊选项：可以指定挂载的额外选项"></a>-o 特殊选项：可以指定挂载的额外选项</h1>]]></content>
    
    
    <summary type="html">对Linux分区文件系统的介绍，文件系统常用命令，fdisk分区，/etc/fstab文件修复，分配swap分区。</summary>
    
    
    
    <category term="Linux" scheme="https://1.15.86.100/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux-用户管理</title>
    <link href="https://1.15.86.100/2021/08/14/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <id>https://1.15.86.100/2021/08/14/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</id>
    <published>2021-08-14T08:44:51.000Z</published>
    <updated>2021-08-15T03:00:07.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h2 id="用户管理文件"><a href="#用户管理文件" class="headerlink" title="用户管理文件"></a>用户管理文件</h2><h3 id="etc-passwd【用户信息文件】"><a href="#etc-passwd【用户信息文件】" class="headerlink" title="/etc/passwd【用户信息文件】"></a>/etc/passwd【用户信息文件】</h3><p>可以使用<code>man 5 passwd</code>查看配置信息。</p><h4 id="配置信息详情"><a href="#配置信息详情" class="headerlink" title="配置信息详情"></a>配置信息详情</h4><p><img src="/2021/08/14/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20210814165205912.png" alt="image-20210814165205912"></p><p>每个字段用 <strong>:</strong> 分割。</p><ul><li><p>第1字段：用户名称；</p></li><li><p>第2字段：密码标志 ；</p></li><li><p>第3字段：UID（用户ID） ；</p></li><li><ul><li>0：   超级用户 ；<ul><li>1-499：  系统用户（伪用户）；</li><li>500-65535： 普通用户(centos7 从1000开始计算)；</li></ul></li></ul></li><li><p>第4字段：GID（用户初始组ID）[不推荐修改初始组]；</p></li><li><p>第5字段：用户说明 ；</p></li><li><p>第6字段：家目录 ；</p></li><li><ul><li>普通用户：/home/用户名/； <ul><li>超级用户：/root/ ；</li></ul></li></ul></li><li><p>第7字段：登录之后的Shell；</p></li></ul><h3 id="etc-shadow【影子文件】"><a href="#etc-shadow【影子文件】" class="headerlink" title="/etc/shadow【影子文件】"></a>/etc/shadow【影子文件】</h3><p>可以使用<code>man 5 shadow</code>查看配置信息。</p><h4 id="详细配置信息"><a href="#详细配置信息" class="headerlink" title="详细配置信息"></a>详细配置信息</h4><p><img src="/2021/08/14/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20210814170742873.png" alt="image-20210814170742873"></p><ul><li><p>第1字段：用户名；</p></li><li><p>第2字段：加密密码 ；</p></li><li><ul><li>加密算法升级为SHA512散列加密算法；<ul><li>如果密码位是<strong>“!!”</strong>或<strong>“*”</strong>代表没有密码，不能登录；</li></ul></li></ul></li><li><p>第3字段：密码最后一次修改日期；</p></li><li><ul><li>使用1970年1月1日作为标准时间，每过一天时间戳加1；</li></ul></li><li><p>第4字段：两次密码的修改间隔时间（和第3字段相比）；</p></li><li>第5字段：密码有效期（和第3字段相比）；</li><li><p>第6字段：密码修改到期前的警告天数（和第5字段相比）；</p></li><li><p>第7字段：密码过期后的宽限天数（和第5 字段相比）；</p></li><li><ul><li>0：代表密码过期后立即失效；<ul><li>-1：则代表密码永远不会失效； </li></ul></li></ul></li><li><p>第8字段：账号失效时间；</p></li><li><ul><li>要用时间戳表示 </li></ul></li><li><p>第9字段：保留</p></li></ul><h3 id="etc-group【组信息文件】"><a href="#etc-group【组信息文件】" class="headerlink" title="/etc/group【组信息文件】"></a>/etc/group【组信息文件】</h3><p>可以使用<code>man 5 group</code>查看配置信息。</p><h4 id="详细信息"><a href="#详细信息" class="headerlink" title="详细信息"></a>详细信息</h4><p><img src="/2021/08/14/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20210814171614809.png" alt="image-20210814171614809"></p><ul><li>第一字段：组名；</li><li>第二字段：组密码标志；</li><li>第三字段：GID；</li><li>第四字段：组中附加用户；</li></ul><h3 id="etc-gshadow【组密码文件】"><a href="#etc-gshadow【组密码文件】" class="headerlink" title="/etc/gshadow【组密码文件】"></a>/etc/gshadow【组密码文件】</h3><ul><li>第一字段：组名；</li><li>第二字段：组密码 (不推荐使用，可以理解为给组设置个小组长)；</li><li>第三字段：组管理员用户名；</li><li>第四字段：组中附加用户；</li></ul><h3 id="用户相关目录"><a href="#用户相关目录" class="headerlink" title="用户相关目录"></a>用户相关目录</h3><h4 id="家目录"><a href="#家目录" class="headerlink" title="家目录"></a>家目录</h4><ul><li>普通用户：<code>/home/用户名/</code>，所有者和所属组都是此用户，权限是700 </li><li>超级用户：<code>/root/</code>，所有者和所属组都是root用户，权限是550 </li></ul><h4 id="用户邮箱"><a href="#用户邮箱" class="headerlink" title="用户邮箱"></a>用户邮箱</h4><ul><li><code>/var/spool/mail/用户名/</code> </li></ul><h4 id="用户模板目录"><a href="#用户模板目录" class="headerlink" title="用户模板目录"></a>用户模板目录</h4><ul><li><code>/etc/skel/</code></li></ul><h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><p>添加用户</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useradd [选项] [用户名]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -u UID： 手工指定用户的UID号</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 家目录： 手工指定用户的家目录</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -c 用户说明： 手工指定用户的说明</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -g 组名： 手工指定用户的初始组</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -G 组名： 指定用户的附加组</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -s shell： 手工指定用户的登录shell。默认是/bin/bash</span> </span><br></pre></td></tr></tbody></table></figure><h3 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h3><p>修改密码</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">passwd [选项] 用户名</span><br><span class="line"><span class="meta">#</span><span class="bash"> -S  查询用户密码的密码状态。仅root用户可用。</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> -l  暂时锁定用户。仅root用户可用</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -u  解锁用户。仅root用户可用</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> --stdin 可以通过管道符输出的数据作为用户的密码。</span></span><br></pre></td></tr></tbody></table></figure><h3 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h3><p>修改用户信息</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">usermod [选项] 用户名</span><br><span class="line"><span class="meta">#</span><span class="bash"> -u UID：修改用户的UID号</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -c 用户说明：修改用户的说明信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -G 组名：修改用户的附加组</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -L：临时锁定用户（Lock）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -U：解锁用户锁定（Unlock）</span></span><br></pre></td></tr></tbody></table></figure><h3 id="chage"><a href="#chage" class="headerlink" title="chage"></a>chage</h3><p>修改用户信息</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chage [选项] 用户名</span><br><span class="line"><span class="meta">#</span><span class="bash"> -l：列出用户的详细密码状态</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 日期：修改密码最后一次更改日期（shadow3字段）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -m 天数：两次密码修改间隔（4字段）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -M 天数：密码有效期（5字段）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -W 天数：密码过期前警告天数（6字段）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -I 天数：密码过后宽限天数（7字段）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -E 日期：账号失效时间（8字段）</span></span><br></pre></td></tr></tbody></table></figure><h3 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h3><p>删除用户</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userdel [-r] 用户名 </span><br><span class="line"><span class="meta">#</span><span class="bash"> -r：删除用户的同时删除用户家目录</span> </span><br></pre></td></tr></tbody></table></figure><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>查看用户<strong>id</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id 用户名</span><br></pre></td></tr></tbody></table></figure><h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>切换用户</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su [选项] 用户名</span><br><span class="line"><span class="meta">#</span><span class="bash"> -：选项只使用“-”代表连带用户的环境变量一起切换  (env命令查看当前环境变量)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -c 命令：仅执行一次命令，而不切换用户身份</span></span><br></pre></td></tr></tbody></table></figure><h2 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h2><h4 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h4><p>添加组</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd [选项] 组名</span><br><span class="line"><span class="meta">#</span><span class="bash"> -g GID：指定组ID</span></span><br></pre></td></tr></tbody></table></figure><h4 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h4><p>修改组</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupmod [选项] 组名</span><br><span class="line"><span class="meta">#</span><span class="bash"> -g GID 修改组ID</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -n 新组名 修改组名</span></span><br></pre></td></tr></tbody></table></figure><h4 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h4><p>删除组</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel [选项] 组名</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">Linux用户管理配置，用户管理命令：用户信息文件、影子文件、组信息文件。</summary>
    
    
    
    <category term="Linux" scheme="https://1.15.86.100/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux-软件包管理</title>
    <link href="https://1.15.86.100/2021/08/14/Linux-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>https://1.15.86.100/2021/08/14/Linux-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/</id>
    <published>2021-08-14T07:57:13.000Z</published>
    <updated>2021-08-14T08:03:38.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h1><h2 id="软件包分类"><a href="#软件包分类" class="headerlink" title="软件包分类"></a>软件包分类</h2><h4 id="源码包"><a href="#源码包" class="headerlink" title="源码包"></a>源码包</h4><p>源码包的<strong>优点</strong>： </p><ul><li><p>开源，如果有足够的能力，可以修改源代码 ；</p></li><li><p>可以自由选择所需的功能 ；</p></li><li><p>软件是编译安装，所以更加适合自己的系统，更加稳定也效率更高 ；</p></li><li><p>卸载方便；</p></li></ul><p>源码包的<strong>缺点</strong>： </p><ul><li><p>安装过程步骤较多，尤其安装较大的软件集合时（如LAMP环境搭建），容易出现拼写错误；</p></li><li><p>编译过程时间较长，安装比二进制安装时间长 ；</p></li><li><p>因为是编译安装，安装过程中一旦报错新手很难解决；</p></li></ul><h4 id="RPM包（二进制）"><a href="#RPM包（二进制）" class="headerlink" title="RPM包（二进制）"></a>RPM包（二进制）</h4><p>二进制包的<strong>优点</strong> </p><ul><li><p>包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载 ；</p></li><li><p>安装速度比源码包安装快的多；</p></li></ul><p>二进制包<strong>缺点</strong>：</p><ul><li>经过编译，不再可以看到源代码； </li><li>功能选择不如源码包灵活 ；</li><li>依赖性；</li></ul>]]></content>
    
    
    <summary type="html">Linux软件包的介绍、安装等操作。</summary>
    
    
    
    <category term="Linux" scheme="https://1.15.86.100/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>TF-IDF</title>
    <link href="https://1.15.86.100/2021/08/12/TF-IDF/"/>
    <id>https://1.15.86.100/2021/08/12/TF-IDF/</id>
    <published>2021-08-12T09:16:06.000Z</published>
    <updated>2021-08-12T11:37:49.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>TF-IDF（Term Frequency-Inverse Document Frequency，词频-逆文档频率）</strong>算法，是信息检索中常用得统计算法。其主要目的是，反应文档或者语句中某些字词得重要程度。某篇文章中字词 <strong>A</strong> 的<strong>TF-IDF</strong>值随着 <strong>A</strong> 在该文档中出现的次数增多而增加，随着 <strong>A</strong> 在其他文档中出现的次数的增多而减少。</p><h2 id="TF"><a href="#TF" class="headerlink" title="TF"></a>TF</h2><p><strong>TF（Term Frequency）</strong>即词频，表示<strong>某个字词</strong>在某个文档中出现的次数占该文档中<strong>所有出现字词</strong>的比例。</p><h4 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h4><script type="math/tex; mode=display">\mathrm{tf}(t,d)=\frac{f_{t,d}}{\sum_{t'\in d}f_{t',d}}</script><p>其中：</p><ul><li><script type="math/tex">f_{t,d}</script>​：表示字词 <strong>t</strong> 在文档 <strong>d</strong> 中出现的次数；</li></ul><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>TF的值，<script type="math/tex">\mathrm{tf}(t,d)</script>​​ 还有其他<strong>定义方式</strong>：</p><ul><li>仅仅表示<strong>词频</strong>：<script type="math/tex">\mathrm{tf}(t,d)=f_{t,d}</script>；</li><li>布尔型：<script type="math/tex">\begin{equation}\mathrm{tf}(t,d)=\left\{ \begin{aligned} 1\ \ if\ t\in d\\ 0\ \ else \end{aligned} \right. \end{equation}</script>​</li><li><strong>对数放缩</strong>：<script type="math/tex">\mathrm{tf}(t,d)=\log{(1+f_{t,d})}</script></li><li><strong>增强频率</strong>（避免长文档的偏差）​：<script type="math/tex">\mathrm{tf}(t,d)=0.5+0.5\cdot \frac{f_{t,d}}{\max{(f_{t',d}:t'\in d)}}</script></li></ul><h2 id="IDF"><a href="#IDF" class="headerlink" title="IDF"></a>IDF</h2><p><strong>IDF（Inverse Document Frequency）</strong>即<strong>逆文档频率</strong>，表示该字词的重要性，如果该字词在该文档出现频率高而很少出现在其他文档则表示该字词更重要。</p><h4 id="计算公式-1"><a href="#计算公式-1" class="headerlink" title="计算公式"></a>计算公式</h4><script type="math/tex; mode=display">\mathrm{idf}(t,D)=\log{\frac{N}{|\{d\in D:t\in d\}|}}$$​其中：* **N**：表示**语料库**中**文档**总数：$$N=|D|$$；* $$|\{d\in D:t\in d\}|$$​：包含 **t** 字词的文档个数；#### 补充* 平滑**IDF**：$$\mathrm{idf}(t,D)=\log{(\frac{N}{1+n_t})}+1$$；* 仅仅使用频率：$$\mathrm{idf}(t,D)=N$$；* 最大**IDF**：$$\mathrm{idf}(t,D)=\log{\frac{\max_{\{t'\in d\}}n_{t'}}{1+n_t}}</script><ul><li>概率<strong>IDF</strong>：<script type="math/tex">\mathrm{idf}(t,D)=\log{\frac{N-n_t}{n_t}}</script></li></ul><h2 id="TF-IDF-1"><a href="#TF-IDF-1" class="headerlink" title="TF-IDF"></a>TF-IDF</h2><h4 id="计算公式-2"><a href="#计算公式-2" class="headerlink" title="计算公式"></a>计算公式</h4><script type="math/tex; mode=display">\mathrm{tfidf}(t,d,D)=\mathrm{tf}(t,d)\cdot \mathrm{idf}(t, D)</script><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://en.wikipedia.org/wiki/Tf–idf">维基百科：TF-IDF</a></li></ul>]]></content>
    
    
    <summary type="html">对TF-IDF算法得介绍以及代码实现。</summary>
    
    
    
    <category term="NLP" scheme="https://1.15.86.100/categories/NLP/"/>
    
    
  </entry>
  
  <entry>
    <title>组合数学-整数拆分数</title>
    <link href="https://1.15.86.100/2021/08/12/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%E6%95%B0/"/>
    <id>https://1.15.86.100/2021/08/12/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%E6%95%B0/</id>
    <published>2021-08-12T08:04:10.000Z</published>
    <updated>2021-08-12T08:23:14.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整数拆分数"><a href="#整数拆分数" class="headerlink" title="整数拆分数"></a>整数拆分数</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>整数拆分</strong>即将一个整数拆分成其他整数（大于0）之和，要求计算其拆分种类个数。</p><h2 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h2><h3 id="欧拉方法"><a href="#欧拉方法" class="headerlink" title="欧拉方法"></a>欧拉方法</h3><p>令：<script type="math/tex">G(x)=(1+x+x^2+\cdots)(1+x^2+x^4+\cdots)\cdots(1+x^m+x^{2m}+\cdots)</script></p><p>则<strong>整数拆分数</strong>等于 <script type="math/tex">x^n</script> 的系数。</p><h3 id="Ferrers图"><a href="#Ferrers图" class="headerlink" title="Ferrers图"></a>Ferrers图</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><img src="/2021/08/12/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%E6%95%B0/image-20210812161257896.png" alt="image-20210812161257896"></p><p><img src="/2021/08/12/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%E6%95%B0/image-20210812161655726.png" alt="image-20210812161655726"></p><p><strong>Ferrers图像</strong>中，格子总数表示<strong>待拆分的整数</strong>，其格子按照行数<strong>从大到小</strong>的阶梯状排序，其<strong>列数</strong>表示拆分成的整数个数，其<strong>行数</strong>表示拆分成的整数值。</p><p>将<strong>Ferrers图像</strong>翻转的到的图像称为<strong>共轭Ferrers图像</strong>。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>整数 <strong>n</strong> 拆分成<strong>最大数为k</strong>的拆分数，和，拆分成<strong>k个数的和</strong>的拆分数是相等的。</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>利用<strong>Ferrers图像</strong>和<strong>共轭Ferrers图像</strong>可以证明。</p><h2 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h2><p><a href="https://www.bilibili.com/video/BV1vZ4y1j7gf?p=26">【学堂在线】组合数学_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <summary type="html">介绍整数拆分数以及Ferrers图像。</summary>
    
    
    
    <category term="组合数学" scheme="https://1.15.86.100/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>组合数学-母函数</title>
    <link href="https://1.15.86.100/2021/08/11/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-%E6%AF%8D%E5%87%BD%E6%95%B0/"/>
    <id>https://1.15.86.100/2021/08/11/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-%E6%AF%8D%E5%87%BD%E6%95%B0/</id>
    <published>2021-08-11T13:49:07.000Z</published>
    <updated>2021-08-11T14:13:12.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="母函数"><a href="#母函数" class="headerlink" title="母函数"></a>母函数</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>生成函数</strong>即<strong>母函数</strong>，是组合数学中尤其是计数方面的一个重要理论和工具。</p><ul><li>计数工具；</li><li>不考虑代数函数性质（收敛，极值）；</li><li>不在乎变量值；</li><li>母函数是将计数问题映射到函数多项式；</li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="掷骰子问题"><a href="#掷骰子问题" class="headerlink" title="掷骰子问题"></a>掷骰子问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><blockquote><p>求：投掷 <strong>m</strong> 个骰子，其点数之和为 <strong>n</strong> 的可能方式总数。</p></blockquote><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>令 <script type="math/tex">G(x)=(x+x^2+x^3+x^4+x^5+x^6)^m</script></p><p>则，其展开式中 <script type="math/tex">x^n</script> 前面的<strong>系数</strong>就是可能的方法数量。</p><h3 id="砝码称重问题"><a href="#砝码称重问题" class="headerlink" title="砝码称重问题"></a>砝码称重问题</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><blockquote><p>现在有 1g，2g，3g，4g 四个砝码，求能称重（只考虑砝码叠加）的数量多少？</p></blockquote><h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p><strong>母函数</strong>：<script type="math/tex">G(x)=(1+x)(1+x^2)(1+x^3)(1+x^4)</script></p><p>展开后有：<script type="math/tex">G(x)=1+x+x^2+2x^3+2x^4+2x^5+2x^6+2x^7+x^8+x^9+x^{10}</script></p><p>指数表示<strong>可以称重的克数</strong>，系数表示<strong>方案数</strong>。</p><h3 id="二进制称重"><a href="#二进制称重" class="headerlink" title="二进制称重"></a>二进制称重</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><blockquote><p>现在有 1g，2g，4g，8g 四个砝码，求能称重（只考虑砝码叠加）的数量多少？</p></blockquote><h4 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h4><p><strong>母函数</strong>：<script type="math/tex">G(x)=(1+x)(1+x^2)(1+x^4)(1+x^8)</script>​</p><p>展开后有：<script type="math/tex">G(x)=1+x+x^2+x^3+x^4+x^5+x^6+x^7+x^8+x^9+x^{10}+x^{11}+x^{12}+x^{13}+x^{14}+x^{15}</script></p><p><strong>系数</strong>都为1，所以可以发现：<strong>所有十进制整数都可以表示成唯一的二进制数</strong></p><h3 id="整数拆分问题"><a href="#整数拆分问题" class="headerlink" title="整数拆分问题"></a>整数拆分问题</h3><h4 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h4><blockquote><p>将整数 <strong>n</strong>，拆分成 1，2，3，……，m 的和，并允许重复</p></blockquote><h4 id="解决方法-3"><a href="#解决方法-3" class="headerlink" title="解决方法"></a>解决方法</h4><p><strong>母函数</strong>：<script type="math/tex">G(x)=(1+x+x^2+\cdots)(1+x^2+x^4+\cdots)\cdots(1+x^m+x^{2m}+\cdots)</script></p><h2 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h2><p><a href="https://www.bilibili.com/video/BV1vZ4y1j7gf?p=23&amp;spm_id_from=pageDriver">【学堂在线】组合数学_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <summary type="html">介绍母函数及其基本用法。</summary>
    
    
    
    <category term="组合数学" scheme="https://1.15.86.100/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>组合数学-全排列算法</title>
    <link href="https://1.15.86.100/2021/08/11/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/"/>
    <id>https://1.15.86.100/2021/08/11/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/</id>
    <published>2021-08-11T13:28:11.000Z</published>
    <updated>2021-08-11T13:49:37.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>给定 <script type="math/tex">{1,2,\cdots,n}</script>，共 <strong>n</strong> 个元素，求得所有的全排列结果。</p><h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><h2 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h2><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><ol><li>将原数据按从小到大排列，获得<strong>字典序</strong>最小的排列结果，记为：<script type="math/tex">x_1,x_2,\dots,x_n</script>；</li><li><strong>从右到左</strong>，找到第一次出现<strong>下降</strong>的位置，记为：<script type="math/tex">x_i</script>；</li><li>找出 <script type="math/tex">x_i</script> 后面比 <script type="math/tex">x_i</script><strong>大的最小</strong>的数 <script type="math/tex">x_j</script>；</li><li>交换 <script type="math/tex">x_i,x_j</script>；</li><li>将第 <script type="math/tex">i</script> 个位置后面的排列变成字典序最小的排列（升序排列）；</li><li>重复上述步骤，直到获得<strong>字典序最大</strong>排列（降序排列）</li></ol><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>获取 <strong>839647521</strong> 的下一个排列；</p><ol><li><strong>从左到右</strong>，<strong>1257</strong>都是升序，<strong>4</strong>是第一次下降；</li><li><strong>4</strong>后面的数中，<strong>5</strong>是大于<strong>4</strong>且最小的数；</li><li>交换 <strong>4</strong> 和 <strong>5</strong>，得到：<strong>839657421</strong>；</li><li>将 <strong>5</strong> 后面的序列 <strong>7421</strong> 变成最小字典序排列，即<strong>1247</strong>；</li><li>得到下一个排列：<strong>839651247</strong>；</li></ol><h2 id="SJT算法"><a href="#SJT算法" class="headerlink" title="SJT算法"></a>SJT算法</h2><h2 id="REF"><a href="#REF" class="headerlink" title="REF**"></a>REF**</h2><p><a href="https://www.bilibili.com/video/BV1vZ4y1j7gf?p=17">【学堂在线】组合数学_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <summary type="html">介绍生成全排列的方法，递归、字典序、SJT算法。</summary>
    
    
    
    <category term="组合数学" scheme="https://1.15.86.100/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>组合数学-排列组合</title>
    <link href="https://1.15.86.100/2021/08/11/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    <id>https://1.15.86.100/2021/08/11/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</id>
    <published>2021-08-11T08:00:21.000Z</published>
    <updated>2021-08-11T09:57:26.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h1><h2 id="多重排列"><a href="#多重排列" class="headerlink" title="多重排列"></a>多重排列</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>对于若干个元素，<script type="math/tex">r_1</script>个1，<script type="math/tex">r_2</script>个2，……<script type="math/tex">r_t</script>个t，元素个数之和为<strong>n</strong>，即<script type="math/tex">\sum_{i=1}^{t}r_i = n</script>​，那么其**全排列记为：<script type="math/tex">P(n;r_1,r_2,\cdots,r_t)</script>​。​</p><h4 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h4><script type="math/tex; mode=display">P(n;r_1,r_2,\cdots,r_t)=\frac{n!}{r_1!r_2!\cdots r_t!}</script><h2 id="无重组合"><a href="#无重组合" class="headerlink" title="无重组合"></a>无重组合</h2><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>从 <strong>n</strong> 个不同的元素中，取 <strong>r</strong> 个不重复的元素，组成一个子集，不考虑顺序，记为：<script type="math/tex">C(n,r)</script>​</p><h4 id="计算公式-1"><a href="#计算公式-1" class="headerlink" title="计算公式"></a>计算公式</h4><script type="math/tex; mode=display">C(n,r)=\frac{n!}{(n-r)!r!}</script><h2 id="无重排列"><a href="#无重排列" class="headerlink" title="无重排列"></a>无重排列</h2><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>从 <strong>n</strong> 个不同的元素中，取 <strong>r</strong> 个不重复的元素，按次序排列，记为：<script type="math/tex">P(n,r)</script></p><h4 id="计算公式-2"><a href="#计算公式-2" class="headerlink" title="计算公式"></a>计算公式</h4><script type="math/tex; mode=display">P(n,r)=\frac{n!}{(n-r)!}</script><h2 id="可重组合"><a href="#可重组合" class="headerlink" title="可重组合"></a>可重组合</h2><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>从n个不同的元素中，取r个元素，可以重复选取，记为：<script type="math/tex">\bar{C}(n,r)</script>​</p><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>取 <script type="math/tex">r</script>​ 个无标志的球，放入 <script type="math/tex">n</script>​​ 个有区别的盒子中，可以放0个或多余1个。</p><h4 id="计算公式-3"><a href="#计算公式-3" class="headerlink" title="计算公式"></a>计算公式</h4><script type="math/tex; mode=display">\bar{C}(n,r)=C(n+r-1, r)</script><h2 id="可重排列"><a href="#可重排列" class="headerlink" title="可重排列"></a>可重排列</h2><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>从n个不同的元素中，取r个进行排列，可以重复选取，记为：<script type="math/tex">P(n,r)</script></p><h4 id="计算公式-4"><a href="#计算公式-4" class="headerlink" title="计算公式"></a>计算公式</h4><script type="math/tex; mode=display">P(n,r)=n^r</script><h2 id="不相邻组合"><a href="#不相邻组合" class="headerlink" title="不相邻组合"></a>不相邻组合</h2><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>从<script type="math/tex">A=\{1,2,3,\cdots,n\}</script>中取<strong>r</strong>个不相邻的数进行组合，即不存在相邻的两个数<script type="math/tex">j,j+1</script>​的组合。</p><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><script type="math/tex; mode=display">C(n-r+1, r)</script><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>设<script type="math/tex">B=\{b_1,b_2,\cdots,b_r\}</script>是一组不相邻的组合；</p><p>让<strong>B</strong>序列元素分别减去其序号，构造<strong>C</strong>序列：<script type="math/tex">C=\{b_1-0,b_2-1,\cdots,b_r-(r-1)\}</script>​;</p><p>因为，<strong>B</strong>是不相邻的组合，所以：</p><script type="math/tex; mode=display">b_i<b_{i+1} - 1\to b_i-i+1<b_{i+1}-i+2</script><p>所以：</p><script type="math/tex; mode=display">c_1<c_2<\cdots c_r</script><p>又因为：<script type="math/tex">c_1=b_1-0\ge 1,c_r=b_r-r+1\le n-r+1</script></p><p>所以，组合数为：<script type="math/tex">C(n-r+1, r)</script>​</p><h4 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h4><p><a href="https://www.bilibili.com/video/BV1vZ4y1j7gf?p=22&amp;spm_id_from=pageDriver">【学堂在线】组合数学_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <summary type="html">排列组合基本概念公式、多重全排列等。</summary>
    
    
    
    <category term="组合数学" scheme="https://1.15.86.100/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="排列组合" scheme="https://1.15.86.100/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>SG函数</title>
    <link href="https://1.15.86.100/2021/07/14/SG%E5%87%BD%E6%95%B0/"/>
    <id>https://1.15.86.100/2021/07/14/SG%E5%87%BD%E6%95%B0/</id>
    <published>2021-07-14T09:15:40.000Z</published>
    <updated>2021-08-10T14:17:10.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SG-Sprague–Grundy-函数"><a href="#SG-Sprague–Grundy-函数" class="headerlink" title="SG(Sprague–Grundy)函数"></a>SG(Sprague–Grundy)函数</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在<strong>博弈论</strong>中，任何一个<strong>公平组合游戏</strong>都可以通过把每个<strong>局面（状态）</strong>看成一个<strong>顶点</strong>，对每个局面和它的子局面连一条有向边来抽象成一个<strong>有向图</strong>，游戏过程就是状态沿着顶点移动的过程，而<strong>SG函数</strong>就是定义在该<strong>有向图</strong>上的函数。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>组合游戏</strong>需要以下条件：</p><ul><li><p>游戏有且只有<strong>两个玩家</strong>；</p></li><li><p>游戏由两个玩家<strong>交替执行步骤</strong>，并且两位玩家都掌握<strong>完全信息</strong>。</p></li><li><p>游戏满足<strong>结束条件（ending condition）</strong>：</p><ul><li>所有的状态最终都会达到结束；</li><li>所有转移的步骤是有限的；</li></ul></li><li><p>游戏满足<strong>普通条件（normal play condition）</strong>：</p><p>  <strong>不能移动</strong>的玩家<strong>失败</strong>；</p></li></ul><h4 id="必胜点（P点）"><a href="#必胜点（P点）" class="headerlink" title="必胜点（P点）"></a>必胜点（P点）</h4><p>任何处于该点的玩家最终必胜；</p><h4 id="必败点（N点）"><a href="#必败点（N点）" class="headerlink" title="必败点（N点）"></a>必败点（N点）</h4><p>任何处于该点的玩家最终必败；</p><h4 id="相关性质"><a href="#相关性质" class="headerlink" title="相关性质"></a>相关性质</h4><ol><li>所有终结点是<strong>必败点</strong>；</li><li>从任何<strong>必胜点</strong>操作，至少有一种方式可以进入<strong>必败点</strong>；</li><li>无论如何操作，<strong>必败点</strong>只能进入<strong>必胜点</strong>；</li></ol><h3 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h3><h4 id="mex-minimal-excludant-运算"><a href="#mex-minimal-excludant-运算" class="headerlink" title="mex(minimal excludant)运算"></a>mex(minimal excludant)运算</h4><p>在集合上的一个运算，表示<strong>最小</strong>的<strong>不属于</strong>这个集合的<strong>非负整数</strong>。</p><p>例如：</p><ul><li>mex{0, 1, 2, 4} = 3；</li><li>mex{2, 4} = 0；</li><li>mex{} = 0；</li></ul><h4 id="SG-x-函数"><a href="#SG-x-函数" class="headerlink" title="SG(x)函数"></a>SG(x)函数</h4><p>对于任意状态<strong>x</strong>，<strong>SG(x) = mex(S)</strong>。</p><p>其中，<strong>S</strong>表示<strong>x</strong>后继状态的<strong>SG</strong>函数值的集合。</p><p>当<strong>SG函数值=0</strong>时，当前先手玩家必败，否则先手玩家必胜。</p><h4 id="取石子问题"><a href="#取石子问题" class="headerlink" title="取石子问题"></a>取石子问题</h4><blockquote><p>现在你有 <strong>n</strong> 个石子，每次可以取走 <script type="math/tex">a(a\in\{1,2\})</script>​​ 个，两个人轮流取，谁取完了谁就获胜，问先手是否必胜。</p></blockquote><p>首先，0个石子肯定是<strong>必败点</strong>，所以有：<script type="math/tex">SG(0)=0</script>；</p><p>有1个石子时，后继状态只有0，所以有：<script type="math/tex">SG(1) = mex\{SG(0)\}=1</script>；</p><p>有2个石子时，后继状态有0，1，所以有：<script type="math/tex">SG(2)=mex\{SG(1),SG(0)\}=2</script>​</p><p>有3个石子时，后继状态有1，2，所以有：<script type="math/tex">SG(3)=mex\{SG(1),SG(2)\}=0</script></p><p>有4个石子时，后继状态有2，3，所以有：<script type="math/tex">SG(4)=mex\{SG(2),SG(3)\}=1</script>​</p><p>有5个石子时，后继状态有3，4，所以有：<script type="math/tex">SG(5)=mex\{SG(3),SG(4)\}=2</script></p><p>有6个石子时，后继状态有4，5，所以有：<script type="math/tex">SG(6)=mex\{SG(4),SG(5)\}=0</script></p><p>……</p><p>容易发现：<script type="math/tex">SG(x)>0,if\ x>0</script>​，所以<strong>不一定先手必胜</strong>。</p><h3 id="证明（SG-0必败，否则必胜的证明）"><a href="#证明（SG-0必败，否则必胜的证明）" class="headerlink" title="证明（SG=0必败，否则必胜的证明）"></a>证明（SG=0必败，否则必胜的证明）</h3><p>首先，对于<strong>终结点</strong> <script type="math/tex">x</script>，此使令<script type="math/tex">SG(x)=0</script>，且必定属于<strong>必败点</strong>；</p><p>对于 <script type="math/tex">SG(x)= 0</script>​ 的<strong>非终结点</strong> <script type="math/tex">x</script>​：</p><ul><li>因为 <script type="math/tex">SG(x) =0</script>，所以，其<strong>子状态</strong>的<strong>SG值</strong>都不为0，即 <script type="math/tex">SG(y)\neq 0,if\ y\in\ sub(x)</script>；</li><li>而，对于<script type="math/tex">SG(y)\neq 0</script> 的状态 <script type="math/tex">y</script>​，其<strong>子状态集合</strong>中必包含<strong>SG值</strong>为0的状态，即 <script type="math/tex">\exist z,SG(z)=0,if\ z\in\ sub(y)</script>；</li><li>所以，处于 <script type="math/tex">x</script>​ 状态时，先手任意选择，后手选择<strong>到达 <script type="math/tex">z</script>状态</strong>的操作即可到达另一使先手<strong>SG值</strong>为0的状态；</li><li>又，该<strong>游戏图</strong>是<strong>有向无环图</strong>，且<strong>叶结点（终结点）</strong>都为必败点，所以<strong>SG=0</strong>的点必为必败点；</li></ul><p>对于 <script type="math/tex">SG(x) \neq 0</script>的点 <script type="math/tex">x</script>：</p><ul><li>其<strong>子状态集合</strong>中必包含<strong>SG值</strong>为0的状态，即 <script type="math/tex">\exist y,SG(y)=0,if\ y\in\ sub(x)</script>​​；</li><li>选择可以到达<strong>y</strong>状态的路径即可；</li></ul><h3 id="SG定理"><a href="#SG定理" class="headerlink" title="SG定理"></a>SG定理</h3><blockquote><p>游戏和的<strong>SG函数</strong>等于各个游戏SG函数值的<strong>Nim和</strong>。这样就可以将每一个子游戏<strong>分而治之</strong>，从而简化了问题。</p></blockquote><h4 id="Nim和"><a href="#Nim和" class="headerlink" title="Nim和"></a>Nim和</h4><p>将各个数<strong>异或</strong>的结果。</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><ul><li>设 <strong>#S</strong> 是所有子游戏的<strong>Nim和</strong>；</li><li>假设 <strong>#S</strong> 不为0，且最高位为1（假设为第 <strong>k</strong>位）的对应的其中一个子游戏的<strong>SG值</strong>为 <strong>#s</strong>；</li><li>令 <strong>#A</strong> 表示除去 <strong>#s</strong> 后，剩下的所有子游戏的 <strong>Nim和</strong>，则有：<strong>#S = #s ^ #A</strong>；</li><li>令 <strong>#a = #s ^ #S</strong>，既该轮的先手将一个子游戏的<strong>SG值</strong>由<strong>#s</strong>变为<strong>#a</strong>，因为<strong>#S，#s</strong>第 <strong>k</strong>位都为1，所以异或后为0，所以<strong>#a &lt; #s</strong>；</li><li>则有：<strong>#A ^ #a = #A ^ #s ^ #S = #A ^ #s ^ #s ^#A = 0</strong>；</li><li>综上如果 <strong>#S</strong> 不为0，先手总可以使 <strong>#S</strong>变为0，并且各堆的<strong>SG值</strong>是单调递减的，所以最终后手局时各堆 <strong>SG值</strong>都变为0，先手必胜；</li><li>同上如果 <strong>#S</strong>为0，先手必输；</li></ul><p><strong><a href="http://1.15.86.100:9000/Dilworth.pdf">REF</a></strong></p>]]></content>
    
    
    <summary type="html">对SG函数、SG定理的简述和证明。</summary>
    
    
    
    <category term="组合数学" scheme="https://1.15.86.100/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="Algorithm" scheme="https://1.15.86.100/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://1.15.86.100/2021/06/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://1.15.86.100/2021/06/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-06-05T08:34:22.000Z</published>
    <updated>2021-06-05T08:36:38.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><div class="table-container"><table><thead><tr><th>写法</th><th>描述</th></tr></thead><tbody><tr><td>[0-9]</td><td>匹配任何数字</td></tr><tr><td></td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">常用正则表达式。</summary>
    
    
    
    <category term="Python" scheme="https://1.15.86.100/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>卡特兰数</title>
    <link href="https://1.15.86.100/2021/05/26/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
    <id>https://1.15.86.100/2021/05/26/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/</id>
    <published>2021-05-26T11:58:21.000Z</published>
    <updated>2021-05-26T12:28:45.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>将<script type="math/tex">1,2,\cdots,N</script>，<strong>N</strong>个数依次进行入栈出栈操作，求输出的<strong>不同排列顺序的序列</strong>的个数。</p><p>假设<script type="math/tex">f(x)</script>表示<strong>x</strong>个数的序列个数，则对于<strong>N</strong>个数的数列，设<strong>i</strong>是最后出栈的数字，则比<strong>i</strong>小的数有<strong>i-1</strong>个，比<strong>i</strong>大的数有<strong>N-i</strong>个，所以<strong>递归公式</strong>为：</p><script type="math/tex; mode=display">f(N)=\sum_{i=1}^{N}f(i-1)\cdot f(N-i) \tag{*}</script><h2 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h2><script type="math/tex; mode=display">f(N)=\frac{4N-2}{n+1}f(N-1)</script><h2 id="通项公式"><a href="#通项公式" class="headerlink" title="通项公式"></a>通项公式</h2><script type="math/tex; mode=display">f(N)=\frac{C_{2N}^N}{N+1}</script>]]></content>
    
    
    <summary type="html">对卡特兰数的介绍。</summary>
    
    
    
    <category term="组合数学" scheme="https://1.15.86.100/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>RSA</title>
    <link href="https://1.15.86.100/2021/05/25/RSA/"/>
    <id>https://1.15.86.100/2021/05/25/RSA/</id>
    <published>2021-05-25T03:40:20.000Z</published>
    <updated>2021-08-01T08:53:11.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h1><p><strong>RSA</strong>是一种<strong>非对称加密</strong>方法。1977年由<em>Ron Rivest</em>、<em>Adi Shamir</em>和<em>Leonard Adleman</em>一起提出的。当时他们三人都在。RSA就是他们三人姓氏开头字母拼在一起组成的。</p><h3 id="欧拉函数-phi​"><a href="#欧拉函数-phi​" class="headerlink" title="欧拉函数\phi​"></a>欧拉函数<script type="math/tex">\phi</script>​</h3><p>欧拉函数<script type="math/tex">\phi(n)</script>表示从<script type="math/tex">1</script>到<script type="math/tex">n</script>中和<script type="math/tex">n</script>​互质的自然数的个数。</p><p>根据<strong>质数性质</strong>，有以下结论：</p><ul><li><script type="math/tex">\phi(1)=1</script>，因为<script type="math/tex">1</script>和<strong>任何数</strong>互质；</li><li><script type="math/tex">\phi(n)=n-1</script>，<script type="math/tex">n</script>为质数时，<script type="math/tex">n</script>和<script type="math/tex">1\cdots n-1</script>互质；</li></ul><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>如果两个正整数 <script type="math/tex">a</script> 和 <script type="math/tex">n</script> <strong>互质</strong>，则 <script type="math/tex">n</script> 的<strong>欧拉函数</strong> <script type="math/tex">\phi(n)</script> 可以让下面的等式成立：</p><script type="math/tex; mode=display">a^{\phi(n)}=1(\mod{n})</script><h2 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h2><h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><ul><li>随机选择两个<strong>不等</strong>的<strong>质数</strong> <script type="math/tex">p</script> 和 <script type="math/tex">q</script>；</li><li>计算 <script type="math/tex">p,q</script> 的<strong>乘积</strong> <script type="math/tex">n</script>​；【<strong>n</strong>做为<strong>公钥</strong>】</li><li>根据公式计算 <script type="math/tex">\phi(n)=LCM((p-1)(q-1))</script>​​，<strong>LCM</strong>：最小公倍数；</li><li>选择一个人整数<strong>e</strong>，满足：<script type="math/tex">1<e<\phi(n)\ and \ gcd(e,\phi(n))=1</script>​，即在<script type="math/tex">1</script>和<script type="math/tex">\phi(n)</script>之间和<script type="math/tex">\phi(n)</script>​互质的数；【<strong>e</strong>做为<strong>公钥</strong>】</li><li>令<script type="math/tex">d=e^{-1}(mod\ \phi(n))</script>；【<strong>d</strong>做为<strong>私钥</strong>】；</li></ul><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>待加密数据：<script type="math/tex">m</script>；</p><p>计算<strong>密文c</strong>：<script type="math/tex">c(\mod n)=m^e</script></p><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>密文：<script type="math/tex">c</script>；</p><p>计算<strong>原文m</strong>：<script type="math/tex">m(\mod n)=c^d</script></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ol><li>选择两个<strong>质数</strong>：<script type="math/tex">p=61,q=53</script>；</li><li>计算<strong>n</strong>：<script type="math/tex">n=p\cdot q=3233</script>；</li><li>计算欧拉函数：<script type="math/tex">\phi(n)=LCM((p-1)\cdot (q-1))=780</script>​；</li><li>随机取<strong>公钥</strong>（质数）：<script type="math/tex">e=17</script>；</li><li>计算<strong>私钥</strong>：<script type="math/tex">d=413,1=(17\times 413)(\mod780)</script>；</li><li>加密函数：<script type="math/tex">c(m)=m^{17}(\mod 3233)</script></li><li>解密函数：<script type="math/tex">m(c)=c^{413}(\mod 3233)</script></li></ol><h2 id="算法证明"><a href="#算法证明" class="headerlink" title="算法证明"></a>算法证明</h2><h3 id="基于欧拉定理"><a href="#基于欧拉定理" class="headerlink" title="基于欧拉定理"></a>基于欧拉定理</h3><p>对于和 <script type="math/tex">n</script> 互质的<strong>原文</strong>：<strong>m</strong>，需要证明：<script type="math/tex">m^{ed}=m(\mod n)</script></p><p>证明：</p><p>因为 <script type="math/tex">ed=1(\mod \phi(n))</script>​</p><p>有<script type="math/tex">ed=1+h\phi(n)</script></p><p>所以，<script type="math/tex">m^{ed}=m^{1+h\phi(n)}=m(m^{\phi(n)})^h</script>​​</p><p>根据<strong>欧拉定理</strong>：<script type="math/tex">m^{\phi(n)}=1(\mod n)</script></p><p>上式变为：<script type="math/tex">m(1)^h=m</script></p><p>故，原式得证。</p>]]></content>
    
    
    <summary type="html">对RSA加密算法的简单介绍。</summary>
    
    
    
    <category term="密码学" scheme="https://1.15.86.100/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="加密算法" scheme="https://1.15.86.100/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Dilworth定理</title>
    <link href="https://1.15.86.100/2021/05/24/Dilworth%E5%AE%9A%E7%90%86/"/>
    <id>https://1.15.86.100/2021/05/24/Dilworth%E5%AE%9A%E7%90%86/</id>
    <published>2021-05-24T12:04:37.000Z</published>
    <updated>2021-08-10T08:23:38.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dilworth定理"><a href="#Dilworth定理" class="headerlink" title="Dilworth定理"></a>Dilworth定理</h1><h2 id="概念定义"><a href="#概念定义" class="headerlink" title="概念定义"></a>概念定义</h2><ul><li><strong>自反性</strong>：对于集合<strong>A</strong>上的<strong>二元关系R</strong>，<script type="math/tex">xRx,\forall x\in A</script>；</li><li><strong>反对称性</strong>：对于集合<strong>A</strong>上的<strong>二元关系R</strong>，对于 <script type="math/tex">xRy\ \ and\ \ yRx,\forall x,y\in A</script>，有<script type="math/tex">x=y</script>；</li><li><strong>传递性</strong>：对于集合<strong>A</strong>上的<strong>二元关系R</strong>，对于 <script type="math/tex">xRy\ \ and\ \ yRz,\forall x,y,z\in A</script>，有<script type="math/tex">xRz</script>；</li><li><strong>偏序关系</strong>：满足<strong>自反性</strong>、<strong>反对称性</strong>、<strong>传递性</strong>的二元关系；</li><li><strong>偏序集</strong>：<script type="math/tex">(S,\precsim)</script>，集合<strong>S</strong>中任意两个元素之间都存在偏序关系；</li><li><strong>链</strong>：对于一个有序序列<script type="math/tex">(x_1,x_2,\cdots,x_n)</script>，如果<script type="math/tex">x_i\precsim x_j \forall i \le j</script>，则称该序列为<strong>链</strong>；</li><li><strong>反链</strong>：对于一个有序序列<script type="math/tex">(x_1,x_2,\cdots,x_n)</script>，如果<script type="math/tex">\forall i \le j,x_1,x_j</script>都不满足偏序关系<script type="math/tex">\precsim</script>（即不可比），则称该序列为<strong>反链</strong>；</li></ul><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><p>偏序集的<strong>最少</strong>的链的划分数等于其<strong>最长</strong>反链长度。</p><p>【把一个数列划分成最少的<strong>最长不升子序列</strong>的数目就等于这个数列的<strong>最长上升子序列</strong>的长度（LIS)】</p><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p><strong>数学归纳法</strong>：</p><p>设<strong>m</strong>表示<strong>偏序集</strong><script type="math/tex">(S,\precsim)</script>中元素个数。</p><ul><li><p>对于<strong>m=0，1</strong>，命题成立；</p></li><li><p>假设对于<script type="math/tex">m<n(n\in\mathbb{N}^+)</script>时命题成立，下面讨论<strong>m=n</strong>情况：</p><p>  设 <script type="math/tex">a</script> 为 <script type="math/tex">S</script> 中的一个<strong>极大元</strong>，构建偏序集 <script type="math/tex">S':=S-\{a\}</script>，由<strong>假设</strong>，<script type="math/tex">(S’,\precsim)</script> 满足该定理；</p><p>  假设 <script type="math/tex">S'</script> <strong>最小的链划分数</strong>以及<strong>最长反链长度</strong>为 <script type="math/tex">k</script>，划分为 <script type="math/tex">C_1,C_2\cdots,C_k</script> 这些不相交的链，长度为 <script type="math/tex">k</script> 的<strong>反链</strong>为 <script type="math/tex">a_1,a_2,\cdots,a_k</script>。</p><p>  记 <script type="math/tex">b_i</script> 为 <script type="math/tex">C_i</script> 中所有属于长为 <script type="math/tex">k</script> 的<strong>反链</strong>的元素中的<strong>最大元</strong>，构造<script type="math/tex">B:=\{b_1,b_2,\cdots,b_k\}</script>。在 <script type="math/tex">B</script> 中，易知 <script type="math/tex">B</script> 是<strong>反链</strong>，且 <script type="math/tex">C_i</script> 中的不可能存在多余一个元素都在<strong>反链</strong>上，也不会少于1个。</p><p>  下面考虑偏序集 <script type="math/tex">S</script>：</p><ul><li>因为 <script type="math/tex">a</script> 为 <script type="math/tex">S</script> 的<strong>极大元</strong>，那么 <script type="math/tex">\{a,b_1,b_2\cdots,b_k\}</script> 是一条长为 <script type="math/tex">k+1</script> 的<strong>反链</strong>。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">对Dilworth定理的介绍和证明。</summary>
    
    
    
    <category term="组合数学" scheme="https://1.15.86.100/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>以太网帧</title>
    <link href="https://1.15.86.100/2021/05/21/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7/"/>
    <id>https://1.15.86.100/2021/05/21/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7/</id>
    <published>2021-05-21T14:36:11.000Z</published>
    <updated>2021-05-30T08:37:11.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="以太帧"><a href="#以太帧" class="headerlink" title="以太帧"></a>以太帧</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在以太网<strong>链路层</strong>上的<strong>数据包</strong>称作<strong>以太帧</strong>。</p><p><strong>以太帧</strong>起始部分由<strong>前导码</strong>和<strong>帧开始符</strong>【802.3协议】组成。后面紧跟着一个以太网报头，以<strong>MAC地址</strong>说明目的地址和源地址。帧的中部是该帧负载的包含<strong>其他协议报头</strong>的数据包（例如IP协议）。以太帧由一个32位<strong>冗余校验码</strong>结尾。它用于检验数据传输是否出现损坏。</p><p><strong>前导码</strong>用于引起接受节点的注意，实质是告诉接收方准备接受新帧。</p><p>相关的有<strong>Ethernet II</strong>、<strong>802.2 LLC</strong>等协议。</p><h2 id="Ethernet-II"><a href="#Ethernet-II" class="headerlink" title="Ethernet II"></a>Ethernet II</h2><p><img src="/2021/05/21/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7/700px-Ethernet_Type_II_Frame_format.svg.png" alt="img"></p><ul><li><strong>目的硬件地址（Destination MAC Address）</strong>：占 48 bit；</li><li><strong>源硬件地址（Source MAC Address）</strong>：占 48 bit；</li><li><strong>以太类型（Type）</strong>：占 16 bit；</li><li><strong>数据（Data）</strong>：上一层传递的数据；标识封装于<strong>以太网帧</strong>中的上层协议，常见值为16进制：<ul><li>0x800：IPv4；</li><li>0x86DD：IPv6；</li><li>0x806：ARP；</li></ul></li><li><strong>循环校验和（CRC Checksum）</strong>：占 32 bit，进行数据校验；</li></ul>]]></content>
    
    
    <summary type="html">对链路层的以太帧介绍。</summary>
    
    
    
    <category term="Computer Network" scheme="https://1.15.86.100/categories/Computer-Network/"/>
    
    
    <category term="Ethernet II" scheme="https://1.15.86.100/tags/Ethernet-II/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP</title>
    <link href="https://1.15.86.100/2021/05/21/TCP-IP/"/>
    <id>https://1.15.86.100/2021/05/21/TCP-IP/</id>
    <published>2021-05-21T07:45:45.000Z</published>
    <updated>2021-06-01T13:16:47.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h1><h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p><img src="/2021/05/21/TCP-IP/6-19110Q62344I5.gif" alt="img"></p><h3 id="字段含义"><a href="#字段含义" class="headerlink" title="字段含义"></a>字段含义</h3><ul><li><strong>源端口（Source Port）</strong>：源计算机上的应用程序的端口号，占 16 位；</li><li><strong>目的端口（Destination Port）</strong>：目标计算机的应用程序端口号，占 16 位；</li><li><strong>序列号字段（Sequence Number）</strong>：占 32 位。它表示本报文段所发送数据的第一个字节的编号。在 TCP 连接中，所传送的字节流的每一个字节都会按顺序编号；</li><li><strong>确认号字段（Acknowledgement Number）</strong>：占 32 位。它表示接收方期望收到发送方下一个报文段的第一个字节数据的编号。其值是接收计算机即将接收到的下一个序列号，也就是下一个接收到的字节的序列号加1；</li><li><strong>数据偏移字段（Header Length）</strong>：占 4 位，数据段中的<strong>数据</strong>部分起始处，距离 TCP 数据段起始处的字节偏移量；</li><li><strong>保留字段（Resv）</strong>：占 4 位，为 TCP 将来的发展预留空间，目前必须全部为 0；</li><li><strong>标志字段</strong>：占 8 位，<ul><li><strong>CWR（Congestion Window Reduce）</strong>：拥塞窗口减少标志，用来表明它接收到了设置 ECE 标志的 TCP 包。并且，发送方收到消息之后，通过减小发送窗口的大小来降低发送速率；</li><li><strong>ECE（ECN Echo）</strong>：用来在 TCP 三次握手时表明一个 TCP 端是具备 ECN 功能的。在数据传输过程中，它也用来表明接收到的 TCP 包的 IP 头部的 ECN 被设置为 11，即网络线路拥堵；</li><li><strong>URG（Urgent）</strong>：表示本报文段中发送的数据是否包含紧急数据。URG=1 时表示有紧急数据。当 URG=1 时，后面的紧急指针字段才有效；</li><li><strong>ACK</strong>：表示前面的<strong>确认号</strong>字段是否有效。ACK=1 时表示有效。只有当 ACK=1 时，前面的确认号字段才有效。TCP 规定，连接建立后，ACK 必须为 1。</li><li><strong>PSH（Push）</strong>：告诉对方收到该报文段后是否立即把数据推送给上层。如果值为 1，表示应当立即把数据提交给上层，而不是缓存起来；</li><li><strong>RST</strong>：表示是否重置连接。如果 RST=1，说明 TCP 连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接；</li><li><strong>SYN</strong>：在建立连接时使用，用来同步序号。当 <strong>SYN=1，ACK=0</strong> 时，表示这是一个请求建立连接的报文段；当 <strong>SYN=1，ACK=1</strong> 时，表示对方同意建立连接。SYN=1 时，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中 SYN 才为 1；</li><li><strong>FIN</strong>：标记数据是否发送完毕。如果 FIN=1，表示数据已经发送完成，可以释放连接；</li></ul></li><li><strong>窗口大小字段（Window Size）</strong>：占 16 位，它表示从<strong>确认号</strong>开始还可以接收多少字节的数据量，也表示当前接收端的接收窗口还有多少剩余空间，该字段可以用于 TCP 的流量控制；</li><li><strong>TCP 校验和字段（TCP Checksum）</strong>：占 16 位，它用于确认传输的数据是否有损坏。发送端基于数据内容校验生成一个数值，接收端根据接收的数据校验生成一个值。两个值必须相同，才能证明数据是有效的。如果两个值不同，则丢掉这个数据包。Checksum 是根据伪头 + TCP 头 + TCP 数据三部分进行计算的；</li><li><strong>紧急指针字段（Urgent Pointer）</strong>：占16位，仅当前面的 URG 控制位为 1 时才有意义。它指出本数据段中为紧急数据的字节数，占 16 位。当所有紧急数据处理完后，TCP 就会告诉应用程序恢复到正常操作。即使当前窗口大小为 0，也是可以发送紧急数据的，因为紧急数据无须缓存；</li><li><strong>可选字段（Options）</strong>：长度不定，但长度必须是 32bits 的整数倍。</li></ul><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><h3 id="ipv4"><a href="#ipv4" class="headerlink" title="ipv4"></a>ipv4</h3><p><img src="/2021/05/21/TCP-IP/p1.png" alt="ipv4" style="zoom: 60%;"></p><ul><li><strong>版本（Version）</strong>：包含一个 4 位二进制值 0100，用于标识这是 IPv4 数据包。</li></ul><ul><li><p><strong>区分服务（DS）</strong>：以前称为服务类型 (ToS) 字段，DS 字段是一个用于确定每个数据包优先级的 8 位字段。DiffServ 字段的六个最高有效位是区分服务代码点 (DSCP)，而后两位是显式拥塞通知 (ECN) 位。</p></li><li><p><strong>生存时间 （TTL）</strong>：包含用于限制数据包寿命的一个 8 位二进制值。数据包发送方设置初始 TTL 值，数据包每经过一次路由器处理，数值就减少一。如果 TTL 字段的值减为零，则路由器将丢弃该数据包并向源 IP 地址发送 Internet 控制消息协议 (ICMP) 超时消息。</p></li><li><p><strong>协议（Protocol）</strong>：字段用于确定下一级协议。此 8 位二进制值表示数据包包含的数据负载类型，使网络层将数据传送到相应的上层协议。常用的值包括 <strong>ICMP (1)</strong>、<strong>TCP (6)</strong> 和 <strong>UDP (17)</strong>。</p></li><li><p><strong>源 IPv4 地址（Source Address）</strong>：包含表示数据包源 IPv4 地址的 32 位二进制值。源 IPv4 地址始终为单播地址。</p></li><li><p><strong>目的 IPv4 地址（Destination Address）</strong>：包含表示数据包目的 IPv4 地址的 32 位二进制值。目的 IPv4 地址为单播、组播或广播地址。</p></li></ul><ul><li><strong>互联网报头长度 (IHL)</strong>、<strong>总长度</strong>和<strong>报头校验和</strong>字段用于识别和验证数据包。</li></ul><h3 id="ipv6"><a href="#ipv6" class="headerlink" title="ipv6"></a>ipv6</h3><p><img src="/2021/05/21/TCP-IP/p2.png" alt="ipv6" style="zoom:80%;"></p><ul><li><p><strong>版本（Version）</strong>：此字段包含一个 4 位二进制值 0110，用于标识这是 IPv6 数据包；</p></li><li><p><strong>流量类别（Traffic Class）</strong>：此 8 位字段相当于<strong>IPv4 区分服务 (DS)</strong>字段；</p></li><li><p><strong>流量号（Flow Label）</strong>：此 20 位字段建议带有相同流量标签的所有数据包收到路由器的相同处理；</p></li><li><p><strong>有效负载长度（Payload Length）</strong>：此 16 位字段表示 IPv6 数据包的数据部分或负载的长度；</p></li><li><p><strong>下一首部（Next Header）</strong>：此 8 位字段相当于<strong>IPv4 协议</strong>字段。它表示数据包传送的数据负载类型，使网络层将数据传送到相应的上层协议；</p></li><li><p><strong>跳数限制（Hop Limit）</strong>：此 8 位字段取代 IPv4 的 TTL 字段。每个转发数据包的路由器均会使此数值减一。当跳数达到 0 时，会丢弃此数据包，并且会向发送主机转发 ICMPv6 超时消息来指明数据包未到达目的地，因为超过跳数限制。</p></li><li><p><strong>源 IPv6 地址 </strong>：此 128 位字段用于确定发送主机的 IPv6 地址；</p></li><li><p><strong>目的 IPv6 地址</strong>：此 128 位字段用于确定接收主机的 IPv6 地址；</p></li></ul><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p><strong>地址解析协议（Address Resolution Protocol）</strong>，其基本功能为通过目标设备的<strong>IP地址</strong>，查询目标设备的<strong>MAC地址</strong>，以保证通信的顺利进行。</p><h4 id="协议包结构："><a href="#协议包结构：" class="headerlink" title="协议包结构："></a>协议包结构：</h4><p><img src="/2021/05/21/TCP-IP/blog\blog\source\_posts\TCP-IP\p3.png" style="zoom:67%;"></p><ul><li><strong>硬件类型（Hardware type,HTYPE）</strong>：【16bits】指定网络连接协议类型：<ul><li>1：Ethernet；</li></ul></li><li><strong>协议类型（Protocol type,PTYPE）</strong>：【16bits】指定了<strong>ARP请求</strong>的互联网协议：<ul><li>0x0800：ipv4；</li></ul></li><li><strong>硬件地址长度（Hardware length,HLEN）</strong>：【8bits】硬件地址长度，以太网是6字节；</li><li><strong>协议地址长度（Protocol length,PLEN）</strong>：【8bits】网络地址长度，ipv4是4字节；</li><li><strong>操作（Operation）</strong>：【16bits】指定报文的目的：<ul><li>1：请求；</li><li>2：回复；</li></ul></li><li><strong>发送方地址（Sender hardware address,SHA）</strong>:【48bits】发送方<strong>MAC</strong>地址；</li><li><strong>发送方协议地址（Sender protocol address,SPA）</strong>：【32bits】发送方网络地址；</li><li><strong>目地方硬件地址（Target hardware address,THA）</strong>：【48bits】目的方<strong>MAC</strong>地址；</li><li><strong>目的方协议地址（Target protocol address,TPA）</strong>：【32bits】目的方网络地址；</li></ul><h2 id="网络字节顺序"><a href="#网络字节顺序" class="headerlink" title="网络字节顺序"></a>网络字节顺序</h2><p><strong>TCP/IP</strong>定义了标准的用于<strong>协议头</strong>中的二进制整数表示：<strong>网络字节顺序（Network Byte Order）</strong>。</p><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><h4 id="htons"><a href="#htons" class="headerlink" title="htons"></a>htons</h4><ul><li>本地字节顺序 <script type="math/tex">\rightarrow</script> 网络字节顺序 【16bits】</li></ul><h4 id="ntohs"><a href="#ntohs" class="headerlink" title="ntohs"></a>ntohs</h4><ul><li>网络字节顺序 <script type="math/tex">\rightarrow</script> 本地字节顺序 【16bits】</li></ul><h4 id="htonl"><a href="#htonl" class="headerlink" title="htonl"></a>htonl</h4><ul><li>本地字节顺序 <script type="math/tex">\rightarrow</script> 网络字节顺序 【32bits】</li></ul><h4 id="ntohl"><a href="#ntohl" class="headerlink" title="ntohl"></a>ntohl</h4><ul><li>网络字节顺序 <script type="math/tex">\rightarrow</script> 本地字节顺序 【32bits】</li></ul>]]></content>
    
    
    <summary type="html">对TCP/IP的报文结构分析。</summary>
    
    
    
    <category term="Computer Network" scheme="https://1.15.86.100/categories/Computer-Network/"/>
    
    
    <category term="TCP" scheme="https://1.15.86.100/tags/TCP/"/>
    
    <category term="IP" scheme="https://1.15.86.100/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>WireShark</title>
    <link href="https://1.15.86.100/2021/05/21/WireShark/"/>
    <id>https://1.15.86.100/2021/05/21/WireShark/</id>
    <published>2021-05-21T06:46:05.000Z</published>
    <updated>2021-05-21T15:12:23.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WireShark"><a href="#WireShark" class="headerlink" title="WireShark"></a>WireShark</h1><h2 id="WireShark抓包内容分析"><a href="#WireShark抓包内容分析" class="headerlink" title="WireShark抓包内容分析"></a>WireShark抓包内容分析</h2><h3 id="链路层封装"><a href="#链路层封装" class="headerlink" title="链路层封装"></a>链路层封装</h3><p>共占<strong>8*14=112</strong> bit。</p><p><img src="/2021/05/21/WireShark/p1.png" alt="p1" style="zoom: 80%;"></p><ul><li><strong>目的硬件地址（Destination Hardware Address）</strong>：占 48 bit；</li><li><strong>源硬件地址（Source Hardware Address）</strong>：占 48 bit；</li><li><strong>协议类别（Type）</strong>：占 16 bit；</li></ul><h3 id="网络层封装"><a href="#网络层封装" class="headerlink" title="网络层封装"></a>网络层封装</h3><p>共占<strong>8*20=160</strong> bit。</p><p><img src="/2021/05/21/WireShark/p2.png" alt="network" style="zoom:80%;"></p><ul><li><strong>版本号（Version）</strong>：占 4 bit，<strong>ipv4</strong>版本号；</li><li><strong>报文头长度（Header length）</strong>：占 4 bit，表示报文头长度【单位：字节（byte）】；</li><li><strong>区分服务域（Differentiated Services Field）</strong>：占 8 bit，<ul><li><strong>区分服务代码点（Differentiated Services Codepoints）</strong>：占 6 bit，DS标记值；</li><li><strong>显示拥塞通知（Explicit Congestion Notification）</strong>：占 2 bit；</li></ul></li><li><strong>总长度（Total Length）</strong>：占 16 bit；</li><li><strong>标识符（Identification）</strong>：占 16 bit；</li><li><strong>标志位（Flags）</strong>：占 3 bit；</li><li><strong>片位移（Fragment Offset）</strong>：占 13 bit；</li><li><strong>TTL（Time to Live）</strong>：占 8 bit；</li><li><strong>内层封装协议（Protocol）</strong>：占 8 bit；</li><li><strong>头部校验和（Header Checksum）</strong>：占 16 bit；</li><li><strong>源地址（Source Address）</strong>：占 32 bit；</li><li><strong>目标地址（Destination Address）</strong>：占 32 bit，即<strong>ip地址</strong>；</li></ul><h3 id="传输层封装（TCP）"><a href="#传输层封装（TCP）" class="headerlink" title="传输层封装（TCP）"></a>传输层封装（TCP）</h3><p>共占 <strong>8*32=256</strong> bit。</p><p><img src="/2021/05/21/WireShark/p3.png" alt="TCP"></p><ul><li><p><strong>源端口号（Source Port）</strong>：占 16 bit；</p></li><li><p><strong>目的端口号（Destination Port）</strong>：占 16 bit；</p></li><li><p><strong>序列号字段（Sequence Number）</strong>：占 32 bt；</p></li><li><p><strong>确认号字段（Acknowledgement Number）</strong>：占 32 bit；</p></li><li><p><strong>数据偏移字段（Header Length）</strong>：占 4 bit；</p></li><li><strong>标志字段（Flags）</strong>：占 12 bit；</li><li><strong>窗口大小字段（Window）</strong>：占 16 bit；</li><li><strong>校验和字段（Checksum）</strong>：占16 bit；</li><li><strong>紧急指针字段（Urgent Pointer）</strong>：占16 bit；</li><li><strong>可选字段（Option）</strong>：长度不定；</li></ul>]]></content>
    
    
    <summary type="html">关于抓包软件WireShark的使用。</summary>
    
    
    
    <category term="Computer Network" scheme="https://1.15.86.100/categories/Computer-Network/"/>
    
    
    <category term="Computer Network" scheme="https://1.15.86.100/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>Socket</title>
    <link href="https://1.15.86.100/2021/05/20/Socket/"/>
    <id>https://1.15.86.100/2021/05/20/Socket/</id>
    <published>2021-05-20T15:25:26.000Z</published>
    <updated>2021-05-30T15:09:05.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><h2 id="Socket-API"><a href="#Socket-API" class="headerlink" title="Socket API"></a>Socket API</h2><h4 id="WSAStartup"><a href="#WSAStartup" class="headerlink" title="WSAStartup"></a>WSAStartup</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WSAStartup</span><span class="params">(WORD wVersionRequested, LPWSADATA IpWSAData)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><p>使用<strong>Socket</strong>应用程序之前，必须调用<strong>WSAStartup</strong>；</p><ul><li>仅<strong>WinSock</strong>环境下；</li></ul></li><li><p>参数：</p><ul><li><p><strong>WORD wVersionRequested</strong>，指明程序请求使用的<strong>WinSock</strong>版本，<strong>高位字节</strong>指明<strong>副版本</strong>，<strong>低位字节</strong>指明<strong>主版本</strong>；</p><p>  例如：<strong>0x102</strong>表示<strong>2.1</strong>版；</p></li><li><p><strong>LPWSADATA IpWSAData</strong>，指向<strong>WSADATA</strong>的指针，保存返回的实际的<strong>WinSock</strong>的版本信息；</p></li></ul></li></ul><h4 id="WSACleanup"><a href="#WSACleanup" class="headerlink" title="WSACleanup"></a>WSACleanup</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WSACleanup</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>应用程序在完成<strong>Socket</strong>使用后调用；<ul><li>仅<strong>WinSock</strong>环境下；</li></ul></li><li>解除与<strong>Socket</strong>库的绑定；</li><li>释放<strong>Socket</strong>系统资源；</li></ul><h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> protofamily, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><p>创建<strong>套接字</strong>；</p></li><li><p>返回<strong>套接字</strong>描述符；</p></li><li><p>参数：</p><ul><li><p><strong>int protofamily</strong>：指明<strong>协议族</strong>，</p><p>  <strong>PF_INET</strong>——<strong>TCP/IP</strong></p></li><li><p><strong>int type</strong>：指明套接字类型，</p><p>  <strong>SOCK_STREAM</strong>：应用层到传输层（TCP）；</p><p>  <strong>SOCK_DGRAM</strong>：应用层到传输层（UDP）；</p><p>  <strong>SOCK_RAM</strong>：应用层到网络层；</p></li><li><p><strong>int protocol</strong>：指明协议号，0为默认；</p></li></ul></li></ul><h4 id="closesocket"><a href="#closesocket" class="headerlink" title="closesocket"></a>closesocket</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closesocket</span><span class="params">(SOCKET sd)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>关闭一个<strong>套接字</strong>；</li><li>如果多个进程共享一个套接字，调用<strong>closesocket</strong>将套接字<strong>引用计数</strong>减1，减至0才关闭该套接字；</li><li>一个进程中的多个线程对一个套接字的使用没有<strong>计数</strong>功能；</li><li>参数：<ul><li><strong>SOCKET sd</strong>：套接字描述符；</li></ul></li><li>返回：0——成功，<strong>SOCKET_ERROR</strong>——失败；</li></ul><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><p>绑定<strong>套接字</strong>本地<strong>端点地址</strong>；</p></li><li><p>客户端一般不用调用，服务器端需要；</p></li><li><p>参数：</p><ul><li><strong>int sockfd</strong>：套接字描述符；</li><li><strong>const struct sockaddr *addr</strong>：本地端口地址（IP地址+端口号），地址通配符<strong>INADDR_ANY</strong>可以绑定所有端口；</li><li><strong>socklen_t addrlen</strong>：地址大小；</li></ul></li></ul><h4 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> queuesize)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>将<strong>服务器端</strong>的<strong>流套接字</strong>置于<strong>监听状态</strong>；<ul><li>仅用于<strong>服务器端</strong>；</li><li>仅用于<strong>面向连接的流套接字</strong>；</li></ul></li><li>参数：<ul><li><strong>int sockfd</strong>：套接字描述符；</li><li><strong>int queuesize</strong>：请求队列的大小；</li></ul></li></ul><h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *saddr, <span class="keyword">int</span> saddrlen)</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>客户</strong>程序调用<strong>connect</strong>使<strong>客户端套接字sockfd</strong>，与特点计算机的特定端口<strong>saddr</strong>的套接字进行连接；<ul><li>仅用于<strong>客户端</strong>；</li><li>可用于<strong>TCP、UDP</strong>；</li></ul></li></ul><h4 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h4><h4 id="send"><a href="#send" class="headerlink" title="send"></a>send</h4><h4 id="sendto"><a href="#sendto" class="headerlink" title="sendto"></a>sendto</h4><h4 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h4><h4 id="recvfrom"><a href="#recvfrom" class="headerlink" title="recvfrom"></a>recvfrom</h4><h4 id="setsockopt"><a href="#setsockopt" class="headerlink" title="setsockopt"></a>setsockopt</h4><h4 id="getsockopt"><a href="#getsockopt" class="headerlink" title="getsockopt"></a>getsockopt</h4>]]></content>
    
    
    <summary type="html">关于计算机网络套接字Socket。</summary>
    
    
    
    <category term="Computer Network" scheme="https://1.15.86.100/categories/Computer-Network/"/>
    
    
  </entry>
  
</feed>
